<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MB.WinEIDrive</name>
    </assembly>
    <members>
        <member name="T:MB.WinEIDrive.DataHelpers">
            <summary>
            DataHelpers 数据处理。
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.DataHelpers.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.DataHelpers.ToDataView(System.Object)">
            <summary>
            把任意类型转换为DataView 的格式。
            </summary>
            <param name="pObj"></param>
            <returns></returns>
        </member>
        <member name="T:MB.WinEIDrive.ExcelEditHelper">
            <summary>
            为Excel编辑服务的帮助类
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.Import.ImportBase">
            <summary>
            ImportBase 数据导入的基本处理。
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.ExcelEditHelper.#ctor(System.String)">
            <summary>
            构造excel编辑帮助类
            </summary>
            <param name="filePath">excel文件的路径</param>
        </member>
        <member name="M:MB.WinEIDrive.ExcelEditHelper.LoadDataAsExcel(System.String[],System.Data.DataTable)">
            <summary>
            把数据源加载进excel
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.ExcelEditHelper.CommitExcel(System.Object)">
            <summary>
            提交excel中的数据到界面中
            </summary>
            <param name="dataSource">要提交的数据源</param>
        </member>
        <member name="M:MB.WinEIDrive.ExcelEditHelper.clearLastDataInExcel(MB.WinEIDrive.Excel.ExcelFile)">
            <summary>
            清除前一次打开excel时残留的数据
            </summary>
            <param name="excelFile">Excel File编辑对象</param>
            <returns></returns>
        </member>
        <member name="M:MB.WinEIDrive.ExcelEditHelper.fillDataInExcel(System.String,System.String[],MB.WinEIDrive.Excel.ExcelFile,MB.WinEIDrive.Excel.ExcelWorksheet,System.Data.DataTable)">
            <summary>
            在当前的excel中填充数据
            填充头和数据体
            </summary>
            <param name="filePath">excel路径</param>
            <param name="mainKeys">要编辑的对象的主键</param>
            <param name="excelFile">excel访问对象</param>
            <param name="ws">当前的工作薄</param>
            <param name="dt">需要填充的数据源</param>
        </member>
        <member name="T:MB.WinEIDrive.Excel.AbstractRange">
            <summary>
            Base class for classes representing one or more excel cells.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.AbstractRange.#ctor(MB.WinEIDrive.Excel.ExcelWorksheet)">
            <summary>
            Internal.
            </summary>
            <param name="parent"></param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.AbstractRange.SetBorders(MB.WinEIDrive.Excel.MultipleBorders,System.Drawing.Color,MB.WinEIDrive.Excel.LineStyle)">
            <summary>
            Sets borders on one or more excel cells, taking cell position into account.
            </summary>
            <param name="multipleBorders">Borders to set.</param>
            <param name="lineColor">Line color.</param>
            <param name="lineStyle">Line style.</param>
        </member>
        <member name="P:MB.WinEIDrive.Excel.AbstractRange.Formula">
            <summary>
            Gets or sets formula string.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.AbstractRange.IsStyleDefault">
            <summary>
            Returns <b>true</b> if all cells in <see cref="T:MB.WinEIDrive.Excel.AbstractRange">AbstractRange</see> have default
            cell style; otherwise, <b>false</b>.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.AbstractRange.Style">
            <summary>
            Gets or sets cell style (<see cref="T:MB.WinEIDrive.Excel.CellStyle">CellStyle</see>) on one or more excel cells.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.AbstractRange.Value">
            <summary>
            Gets or sets cell value on one or more excel cells.
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.Excel.Area3dFormulaToken">
            <summary>
            Formula token for holding 3d reference on internal cell range.
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.Excel.AreaFormulaToken">
            <summary>
            Formula token for holding reference on cell range.
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.Excel.FormulaToken">
            <summary>
            Base formula token class for inheritance
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.FormulaToken.#ctor(MB.WinEIDrive.Excel.FormulaTokenCode,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.FormulaToken"/> class.
            </summary>
            <param name="code">The code.</param>
            <param name="size">The size.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.FormulaToken.ConvertToBytes">
            <summary>
            Convert formula token to bytes representation.
            </summary>
            <returns>bytes representation of the formula token</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.FormulaToken.DelayInitialize(System.Object[])">
            <summary>
            Make custom delay initialize.
            </summary>
            <param name="data">The data for initialization which is unique for each formula token.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.FormulaToken.Read(System.Byte[],System.Int32)">
            <summary>
            Initialize formula token by reading input data from array of bytes
            </summary>
            <param name="rpnBytes">input data, array of bytes</param>
            <param name="startIndex">start position for array of bytes to read from</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.FormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="P:MB.WinEIDrive.Excel.FormulaToken.Size">
            <summary>
            Gets the size of the formula token.
            </summary>
            <value>The size of the formula token.</value>
        </member>
        <member name="P:MB.WinEIDrive.Excel.FormulaToken.Token">
            <summary>
            Gets the formula token code.
            </summary>
            <value>The formula token code.</value>
        </member>
        <member name="M:MB.WinEIDrive.Excel.AreaFormulaToken.#ctor(MB.WinEIDrive.Excel.FormulaTokenCode)">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.AreaFormulaToken"/> class.
            </summary>
            <param name="code">The FormulaTokenCode code.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.AreaFormulaToken.ConvertToBytes">
            <summary>
            Convert formula token to array of byte representation.
            </summary>
            <returns>formula token' array of byte representation</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.AreaFormulaToken.DelayInitialize(System.Object[])">
            <summary>
            Make custom delay initialize.
            </summary>
            <param name="data">The data for initialization which is unique for each formula token.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.AreaFormulaToken.Read(System.Byte[],System.Int32)">
            <summary>
            Initialize formula token by reading input data from array of bytes
            </summary>
            <param name="rpnBytes">input data, array of bytes</param>
            <param name="startIndex">start position for array of bytes to read from</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.AreaFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="F:MB.WinEIDrive.Excel.AreaFormulaToken.firstRow">
            <summary>
            first row.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.AreaFormulaToken.IsCellRangeRegex">
            <summary>
            Regula expression used to determinate whether the input string is cell range( area ) or not
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.AreaFormulaToken.regexOptions">
            <summary>
            Regular expression default settings
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.AreaFormulaToken.FirstRow">
            <summary>
            Gets the first row.
            </summary>
            <value>The first row.</value>
        </member>
        <member name="M:MB.WinEIDrive.Excel.Area3dFormulaToken.#ctor(MB.WinEIDrive.Excel.FormulaTokenCode)">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.Area3dFormulaToken"/> class.
            </summary>
            <param name="code">The FormulaTokenCode code.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.Area3dFormulaToken.ConvertToBytes">
            <summary>
            Convert formula token to array of byte representation.
            </summary>
            <returns>formula token' array of byte representation</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.Area3dFormulaToken.DelayInitialize(System.Object[])">
            <summary>
            Make custom delay initialize.
            </summary>
            <param name="data">The data for initialization which is unique for each formula token.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.Area3dFormulaToken.Read(System.Byte[],System.Int32)">
            <summary>
            Initialize formula token by reading input data from array of bytes
            </summary>
            <param name="rpnBytes">input data, array of bytes</param>
            <param name="startIndex">start position for array of bytes to read from</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.Area3dFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="F:MB.WinEIDrive.Excel.Area3dFormulaToken.IsCellRange3DRegex">
            <summary>
            Regular expression used to determinate whether the input string is 3d cell range( 1t case ) or not
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.Area3dFormulaToken.refIndex">
            <summary>
            REF entry' index on EXTERNSHEET record( see the Link Table ).
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.Area3dFormulaToken.regexOptions">
            <summary>
            Regular expression default options
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.Excel.AreaErr3dFormulaToken">
            <summary>
            Formula token for holding 3d reference error.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.AreaErr3dFormulaToken.#ctor(MB.WinEIDrive.Excel.FormulaTokenCode)">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.AreaErr3dFormulaToken"/> class.
            </summary>
            <param name="code">The FormulaTokenCode code.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.AreaErr3dFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="T:MB.WinEIDrive.Excel.ArrayFormulaToken">
            <summary>
            Formula token for holding array.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ArrayFormulaToken.#ctor(MB.WinEIDrive.Excel.FormulaTokenCode)">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.ArrayFormulaToken"/> class.
            </summary>
            <param name="code">The FormulaTokenCode code.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ArrayFormulaToken.ConvertToBytes">
            <summary>
            Convert formula token to array of byte representation.
            </summary>
            <returns>formula token' array of byte representation</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ArrayFormulaToken.Read(System.Byte[],System.Int32)">
            <summary>
            Initialize formula token by reading input data from array of bytes
            </summary>
            <param name="rpnBytes">input data, array of bytes</param>
            <param name="startIndex">start position for array of bytes to read from</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ArrayFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="T:MB.WinEIDrive.Excel.BinaryOperatorFormulaToken">
            <summary>
            Formula token for holding binary operator.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.BinaryOperatorFormulaToken.#cctor">
            <summary>
            Initializes the <see cref="T:MB.WinEIDrive.Excel.BinaryOperatorFormulaToken"/> class.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.BinaryOperatorFormulaToken.#ctor(MB.WinEIDrive.Excel.FormulaTokenCode)">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.BinaryOperatorFormulaToken"/> class.
            </summary>
            <param name="code">The FormulaTokenCode code.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.BinaryOperatorFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="T:MB.WinEIDrive.Excel.BoolFormulaToken">
            <summary>
            Formula token for holding bool.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.BoolFormulaToken.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.BoolFormulaToken"/> class.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.BoolFormulaToken.ConvertToBytes">
            <summary>
            Convert formula token to array of byte representation.
            </summary>
            <returns>formula token' array of byte representation</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.BoolFormulaToken.DelayInitialize(System.Object[])">
            <summary>
            Make custom delay initialize.
            </summary>
            <param name="data">The data for initialization which is unique for each formula token.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.BoolFormulaToken.Read(System.Byte[],System.Int32)">
            <summary>
            Initialize formula token by reading input data from array of bytes
            </summary>
            <param name="rpnBytes">input data, array of bytes</param>
            <param name="startIndex">start position for array of bytes to read from</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.BoolFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="T:MB.WinEIDrive.Excel.Buffer">
            <summary>
            Buffer class is used as the wrapper aroung input string for FormulaParser providing
            additional helpful methods for accessing string buffer.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.Buffer.Empty">
            <summary>
            Unique char to identify that char is empty
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.Buffer.EmptyInteger">
            <summary>
            Unique integer to identify that integer is null
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.Buffer.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.Buffer"/> class.
            </summary>
            <param name="data">The string data to wrap.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.Buffer.GetCurrent">
            <summary>
            Gets the current ñhar data.
            </summary>
            <returns>current char data</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.Buffer.GetNext">
            <summary>
            Gets the next char from buffer.
            </summary>
            <returns>read char or special char indicating no read status</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.Buffer.GetNextOnDemand(System.Char)">
            <summary>
            Gets the next on demand( if next symbol is peek, than read it and return back ).
            </summary>
            <param name="peek">The char to peek for.</param>
            <returns>read char or special char indicating no read status</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.Buffer.GetNextOnDemand(System.Char[])">
            <summary>
            Gets the next on demand( if next symbol is of the given chars, than read it and return back ).
            </summary>
            <param name="charsToPeekFor">The char array to peek for.</param>
            <returns>
            read char or special char indicating no read status
            </returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.Buffer.GetNextOnDemand(System.Char,System.Boolean)">
            <summary>
            Gets the next on demand( if next symbol is peek, than read it and return back ).
            Additionally it can skip whitespaces on demand.
            </summary>
            <param name="peek">The char to peek for.</param>
            <param name="skipWhitespaces">if set to <c>true</c> [skip whitespaces].</param>
            <returns>
            read char or special char indicating no read status
            </returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.Buffer.GetNextString">
            <summary>
            Gets the next string from buffer with skipping whitespaces.
            </summary>
            <returns>read string</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.Buffer.GetNextString(System.Boolean)">
            <summary>
            Gets the next string from buffer with optional skipping whitespaces.
            </summary>
            <returns>read string</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.Buffer.GetNextString(System.Char[])">
            <summary>
            Gets the next string from buffer.
            </summary>
            <param name="endChars">The arrag of chars used as end marks during reading.</param>
            <returns>read string</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.Buffer.GetNextString(System.Char)">
            <summary>
            Gets the next string from buffer.
            </summary>
            <param name="endChar">The char used as end mark during reading.</param>
            <returns>read string</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.Buffer.GetNextWithWhitespaceSkippling">
            <summary>
            Gets the next on demand( if next symbol is peek, than read it and return back ).
            Additionally it always skip whitespaces.
            </summary>
            <returns>read char or special char indicating no read status</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.Buffer.Peek">
            <summary>
            Peeks for the next char.
            </summary>
            <returns>read char or special char indicating no read status</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.Buffer.Peek(System.Int32)">
            <summary>
            Peeks for the next char at specified forward-position
            </summary>
            <returns>read char or special char indicating no read status</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.Buffer.SkipWhitespaces">
            <summary>
            Skips the whitespaces.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.Buffer.Data">
            <summary>
            Gets the input data string buffer.
            </summary>
            <value>The input data string buffer.</value>
        </member>
        <member name="P:MB.WinEIDrive.Excel.Buffer.IsEOF">
            <summary>
            Gets a value indicating whether we have reached end of input buffer.
            </summary>
            <value><c>true</c> if we have reached end of input buffer; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:MB.WinEIDrive.Excel.Buffer.Pos">
            <summary>
            Gets the position of input data string buffer.
            </summary>
            <value>The position of input data string buffer.</value>
        </member>
        <member name="T:MB.WinEIDrive.Excel.CellBorder">
            <summary>
            Contains settings for a single cell border.
            </summary>
            <remarks>
            Note that although diagonal-up (<see cref="F:MB.WinEIDrive.Excel.IndividualBorder.DiagonalUp">IndividualBorder.DiagonalUp</see>
            or <see cref="F:MB.WinEIDrive.Excel.MultipleBorders.DiagonalUp">MultipleBorders.DiagonalUp</see>) and diagonal-down
            (<see cref="F:MB.WinEIDrive.Excel.IndividualBorder.DiagonalDown">IndividualBorder.DiagonalDown</see> or
            <see cref="F:MB.WinEIDrive.Excel.MultipleBorders.DiagonalDown">MultipleBorders.DiagonalDown</see>) can be individually set,
            they share the same color and the same line style. This is a Microsoft Excel limitation.
            </remarks>
            <seealso cref="T:MB.WinEIDrive.Excel.CellBorders"/>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellBorder.LineColor">
            <summary>
            Gets or sets border line color.
            </summary>
            <remarks>
            Note that although diagonal-up (<see cref="F:MB.WinEIDrive.Excel.IndividualBorder.DiagonalUp">IndividualBorder.DiagonalUp</see>
            or <see cref="F:MB.WinEIDrive.Excel.MultipleBorders.DiagonalUp">MultipleBorders.DiagonalUp</see>) and diagonal-down
            (<see cref="F:MB.WinEIDrive.Excel.IndividualBorder.DiagonalDown">IndividualBorder.DiagonalDown</see> or
            <see cref="F:MB.WinEIDrive.Excel.MultipleBorders.DiagonalDown">MultipleBorders.DiagonalDown</see>) can be individually set,
            they share the same color and the same line style. This is a Microsoft Excel limitation.
            </remarks>
        </member>
        <member name="T:MB.WinEIDrive.Excel.CellBorders">
            <summary>
            Collection of cell borders (<see cref="T:MB.WinEIDrive.Excel.CellBorder">CellBorder</see>).
            </summary>
            <seealso cref="T:MB.WinEIDrive.Excel.CellBorder"/>
        </member>
        <member name="M:MB.WinEIDrive.Excel.CellBorders.SetBorders(MB.WinEIDrive.Excel.MultipleBorders,System.Drawing.Color,MB.WinEIDrive.Excel.LineStyle)">
            <summary>
            Sets specific line color and line style on multiple borders.
            </summary>
            <param name="multipleBorders">Borders to set.</param>
            <param name="lineColor">Border line color.</param>
            <param name="lineStyle">Border line style.</param>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellBorders.Item(MB.WinEIDrive.Excel.IndividualBorder)">
            <summary>
            Gets specific border.
            </summary>
            <param name="individualBorder">Border to get.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.CellFormula.Recalculate">
            <summary>
            Recalculate formula based on saved tokens.
            It need to be done for changing some data which can be changed after setting formula
            and before saving xls file.
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.Excel.CellRange">
            <summary>
            Cell range is a rectangular group of worksheet cells.
            </summary>
            <remarks>
            <p>Cell range is determined by its top (<see cref="P:MB.WinEIDrive.Excel.CellRange.FirstRowIndex">FirstRowIndex</see>),
            left (<see cref="P:MB.WinEIDrive.Excel.CellRange.FirstColumnIndex">FirstColumnIndex</see>),
            bottom (<see cref="P:MB.WinEIDrive.Excel.CellRange.LastRowIndex">LastRowIndex</see>) and
            right (<see cref="P:MB.WinEIDrive.Excel.CellRange.LastColumnIndex">LastColumnIndex</see>) borders. This properties
            are read-only, so if you require different cell range use one of GetSubrange methods
            (<see cref="M:MB.WinEIDrive.Excel.CellRange.GetSubrangeAbsolute(System.Int32,System.Int32,System.Int32,System.Int32)">GetSubrangeAbsolute</see>,
            <see cref="M:MB.WinEIDrive.Excel.CellRange.GetSubrangeRelative(System.Int32,System.Int32,System.Int32,System.Int32)">GetSubrangeRelative</see> or
            <see cref="M:MB.WinEIDrive.Excel.CellRange.GetSubrange(System.String,System.String)">GetSubrange</see>). Specific cell can be accessed in a few
            ways, depending on <see cref="P:MB.WinEIDrive.Excel.CellRange.IndexingMode">IndexingMode</see>. Cells in the
            range can be merged / unmerged by the use of <see cref="P:MB.WinEIDrive.Excel.CellRange.Merged">Merged</see>
            property.</p>
            <p><see cref="P:MB.WinEIDrive.Excel.CellRange.Value">Value</see> property set will set value of multiple cells
            or of a merged range. <see cref="P:MB.WinEIDrive.Excel.CellRange.Value">Value</see> property get has meaning
            only if range is merged; otherwise, exception is thrown.</p>
            <p><see cref="P:MB.WinEIDrive.Excel.CellRange.Style">Style</see> property set will set style of multiple cells
            or of a merged range. <see cref="P:MB.WinEIDrive.Excel.CellRange.Style">Style</see> property get has meaning
            only if range is merged; otherwise, exception is thrown.</p>
            <p> Note that for <see cref="P:MB.WinEIDrive.Excel.CellRange.Style">Style</see> property set on a cell range that
            is not merged, you can't use the following format:
            <code lang="Visual Basic">
            Dim cr As CellRange = excelFile.Worksheets(0).Rows(1).Cells
            cr.Style.Rotation = 30
            </code>
            <code lang="C#">
            CellRange cr = excelFile.Worksheets[0].Rows[1].Cells;
            cr.Style.Rotation = 30;
            </code>
            because that would first call <see cref="P:MB.WinEIDrive.Excel.CellRange.Style">Style</see> property get method and that
            will certainly fail because <see cref="P:MB.WinEIDrive.Excel.CellRange.Style">Style</see> property get is defined only
            for a merged cell range. </p><p>Instead you can use two different code patterns, depending on whether you want to replace or combine the existing
            cell range styles with the new style.</p><p>
            If you want to <b>replace</b> cell style on every cell in a cell range use the following code:
            <code lang="Visual Basic">
            Dim cr As CellRange = excelFile.Worksheets(0).Rows(1).Cells
            Dim style As CellStyle = New CellStyle()
            style.Rotation = 30
            cr.Style = style
            </code>
            <code lang="C#">
            CellRange cr = excelFile.Worksheets[0].Rows[1].Cells;
            CellStyle style = new CellStyle();
            style.Rotation = 30;
            cr.Style = style;
            </code>
            </p><p>
            If you want to <b>set</b> cell style property on every cell in a cell range (other cell style property values will
            remain unchanged) use the following code:
            <code lang="Visual Basic">
            Dim cell As ExcelCell
            For Each cell In excelFile.Worksheets(0).Rows(1).Cells
            cell.Style.Rotation = 30
            Next
            </code>
            <code lang="C#">
            foreach(ExcelCell cell in excelFile.Worksheets[0].Rows[1].Cells)
            cell.Style.Rotation = 30;
            </code>
            </p>
            </remarks>
            <example> Following code creates horizontal, vertical and rectangular cell ranges and demonstrates how
            indexing works different in different context. <see cref="M:MB.WinEIDrive.Excel.CellRange.SetBorders(MB.WinEIDrive.Excel.MultipleBorders,System.Drawing.Color,MB.WinEIDrive.Excel.LineStyle)">SetBorders</see>
            method is used to mark outside borders of the rectangular range.
            <code lang="Visual Basic">
            Dim cr As CellRange = excelFile.Worksheets(0).Rows(1).Cells
            
            cr(0).Value = cr.IndexingMode
            cr(3).Value = "D2"
            cr("B").Value = "B2"
            
            cr = excelFile.Worksheets(0).Columns(4).Cells
            
            cr(0).Value = cr.IndexingMode
            cr(2).Value = "E3"
            cr("5").Value = "E5"
            
            cr = excelFile.Worksheets(0).Cells.GetSubrange("F2", "J8")
            cr.SetBorders(MultipleBorders.Outside, Color.Navy, LineStyle.Dashed)
            
            cr("I7").Value = cr.IndexingMode
            cr(0, 0).Value = "F2"
            cr("G3").Value = "G3"
            cr(5).Value = "F3" <font color="Green">' Cell range width is 5 (F G H I J).</font>
            </code>
            <code lang="C#">
            CellRange cr = excelFile.Worksheets[0].Rows[1].Cells;
            
            cr[0].Value = cr.IndexingMode;
            cr[3].Value = "D2";
            cr["B"].Value = "B2";
            
            cr = excelFile.Worksheets[0].Columns[4].Cells;
            
            cr[0].Value = cr.IndexingMode;
            cr[2].Value = "E3";
            cr["5"].Value = "E5";
            
            cr = excelFile.Worksheets[0].Cells.GetSubrange("F2", "J8");
            cr.SetBorders(MultipleBorders.Outside, Color.Navy, LineStyle.Dashed);
            
            cr["I7"].Value = cr.IndexingMode;
            cr[0,0].Value = "F2";
            cr["G3"].Value = "G3";
            cr[5].Value = "F3"; <font color="Green">// Cell range width is 5 (F G H I J).</font>
            </code>
            </example>
        </member>
        <member name="M:MB.WinEIDrive.Excel.CellRange.CopyTo(System.String)">
            <summary>
            Copies this cell range to another position in the same worksheet.
            </summary>
            <param name="topLeftCell">Full name of the top-left cell of the destination range.</param>
            <remarks>
            <p><i>topLeftCell</i> specifies position of the top-left cell of
            the destination cell range.</p>
            <p>Destination cell range has the same width and height as this cell range.</p>
            <p><see cref="T:System.ArgumentOutOfRangeException"/> is thrown if destination range:
            <list type="bullet">
            <item><description>breaks Excel worksheet row or column limit,</description></item>
            <item><description>overlaps with source range, or</description></item>
            <item><description>overlaps with existing merged range.</description></item>
            </list></p>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if destination range is invalid.</exception>
        </member>
        <member name="M:MB.WinEIDrive.Excel.CellRange.CopyTo(MB.WinEIDrive.Excel.ExcelWorksheet,System.String)">
            <summary>
            Copies this cell range to another worksheet.
            </summary>
            <param name="destinationWorksheet">Destination worksheet.</param>
            <param name="topLeftCell">Full name of the top-left cell of the destination range.</param>
            <remarks>
            <p><i>topLeftCell</i> specifies position of the top-left cell of
            the destination cell range.</p>
            <p>Destination cell range has the same width and height as this cell range.</p>
            <p><see cref="T:System.ArgumentOutOfRangeException"/> is thrown if destination range:
            <list type="bullet">
            <item><description>breaks Excel worksheet row or column limit,</description></item>
            <item><description>overlaps with source range, or</description></item>
            <item><description>overlaps with existing merged range.</description></item>
            </list></p>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if destination range is invalid.</exception>
        </member>
        <member name="M:MB.WinEIDrive.Excel.CellRange.CopyTo(System.Int32,System.Int32)">
            <overloads>Copies this cell range to the specified position.</overloads>
            <summary>
            Copies this cell range to another position in the same worksheet.
            </summary>
            <param name="absoluteRow">Absolute index of the destination row.</param>
            <param name="absoluteColumn">Absolute index of the destination column.</param>
            <remarks>
            <p><i>absoluteRow</i> and <i>absoluteColumn</i> specify position of the top-left cell of
            the destination cell range.</p>
            <p>Destination cell range has the same width and height as this cell range.</p>
            <p><see cref="T:System.ArgumentOutOfRangeException"/> is thrown if destination range:
            <list type="bullet">
            <item><description>breaks Excel worksheet row or column limit,</description></item>
            <item><description>overlaps with source range, or</description></item>
            <item><description>overlaps with existing merged range.</description></item>
            </list></p>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if destination range is invalid.</exception>
        </member>
        <member name="M:MB.WinEIDrive.Excel.CellRange.CopyTo(MB.WinEIDrive.Excel.ExcelWorksheet,System.Int32,System.Int32)">
            <summary>
            Copies this cell range to another worksheet.
            </summary>
            <param name="destinationWorksheet">Destination worksheet.</param>
            <param name="absoluteRow">Absolute index of the destination row.</param>
            <param name="absoluteColumn">Absolute index of the destination column.</param>
            <remarks>
            <p><i>absoluteRow</i> and <i>absoluteColumn</i> specify position of the top-left cell of
            the destination cell range.</p>
            <p>Destination cell range has the same width and height as this cell range.</p>
            <p><see cref="T:System.ArgumentOutOfRangeException"/> is thrown if destination range:
            <list type="bullet">
            <item><description>breaks Excel worksheet row or column limit,</description></item>
            <item><description>overlaps with source range, or</description></item>
            <item><description>overlaps with existing merged range.</description></item>
            </list></p>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if destination range is invalid.</exception>
        </member>
        <member name="M:MB.WinEIDrive.Excel.CellRange.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:MB.WinEIDrive.Excel.CellRange">CellRange</see> is equal
            to the current <see cref="T:MB.WinEIDrive.Excel.CellRange">CellRange</see>.
            </summary>
            <param name="obj">Object of <see cref="T:MB.WinEIDrive.Excel.CellRange">CellRange</see> type.</param>
            <returns><b>true</b> if the specified <see cref="T:MB.WinEIDrive.Excel.CellRange">CellRange</see> is equal
            to the current <see cref="T:MB.WinEIDrive.Excel.CellRange">CellRange</see>; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.CellRange.GetEnumerator">
            <summary>
            Returns an enumerator for the <see cref="T:MB.WinEIDrive.Excel.CellRange">CellRange</see> (all cells).
            </summary>
            <remarks>
            Returns default enumerator that iterates all cells in the range. If you are only reading existing
            cells (values or formatting), use more appropriate <see cref="M:MB.WinEIDrive.Excel.CellRange.GetReadEnumerator"/>.
            </remarks>
        </member>
        <member name="M:MB.WinEIDrive.Excel.CellRange.GetHashCode">
            <summary>
            Returns the hash code of this object.
            </summary>
            <returns>Hash code.</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.CellRange.GetReadEnumerator">
            <summary>
            Returns enumerator for the <see cref="T:MB.WinEIDrive.Excel.CellRange">CellRange</see> (only allocated cells).
            </summary>
            <remarks>
            Returns enumerator that iterates only already allocated cells in the range. If you are only reading existing
            cells (values or formatting), use this enumerator as it is faster and doesn't allocate unnecessary cells.
            </remarks>
        </member>
        <member name="M:MB.WinEIDrive.Excel.CellRange.GetSubrange(System.String,System.String)">
            <summary>
            Returns new cell range using start and end position.
            </summary>
            <param name="firstCell">Name of first (top-left) cell.</param>
            <param name="lastCell">Name of last (bottom-right) cell.</param>
            <remarks>
            New cell range must be within this cell range.
            </remarks>
            <example> Following code creates horizontal, vertical and rectangular cell ranges and demonstrates how
            indexing works different in different context. <see cref="M:MB.WinEIDrive.Excel.CellRange.SetBorders(MB.WinEIDrive.Excel.MultipleBorders,System.Drawing.Color,MB.WinEIDrive.Excel.LineStyle)">SetBorders</see>
            method is used to mark outside borders of the rectangular range.
            <code lang="Visual Basic">
            Dim cr As CellRange = excelFile.Worksheets(0).Rows(1).Cells
            
            cr(0).Value = cr.IndexingMode
            cr(3).Value = "D2"
            cr("B").Value = "B2"
            
            cr = excelFile.Worksheets(0).Columns(4).Cells
            
            cr(0).Value = cr.IndexingMode
            cr(2).Value = "E3"
            cr("5").Value = "E5"
            
            cr = excelFile.Worksheets(0).Cells.GetSubrange("F2", "J8")
            cr.SetBorders(MultipleBorders.Outside, Color.Navy, LineStyle.Dashed)
            
            cr("I7").Value = cr.IndexingMode
            cr(0, 0).Value = "F2"
            cr("G3").Value = "G3"
            cr(5).Value = "F3" <font color="Green">' Cell range width is 5 (F G H I J).</font>
            </code>
            <code lang="C#">
            CellRange cr = excelFile.Worksheets[0].Rows[1].Cells;
            
            cr[0].Value = cr.IndexingMode;
            cr[3].Value = "D2";
            cr["B"].Value = "B2";
            
            cr = excelFile.Worksheets[0].Columns[4].Cells;
            
            cr[0].Value = cr.IndexingMode;
            cr[2].Value = "E3";
            cr["5"].Value = "E5";
            
            cr = excelFile.Worksheets[0].Cells.GetSubrange("F2", "J8");
            cr.SetBorders(MultipleBorders.Outside, Color.Navy, LineStyle.Dashed);
            
            cr["I7"].Value = cr.IndexingMode;
            cr[0,0].Value = "F2";
            cr["G3"].Value = "G3";
            cr[5].Value = "F3"; <font color="Green">// Cell range width is 5 (F G H I J).</font>
            </code>
            </example>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if arguments are out of range.</exception>
            <seealso cref="P:MB.WinEIDrive.Excel.CellRange.StartPosition"/>
            <seealso cref="P:MB.WinEIDrive.Excel.CellRange.EndPosition"/>
            <seealso cref="M:MB.WinEIDrive.Excel.CellRange.GetSubrangeAbsolute(System.Int32,System.Int32,System.Int32,System.Int32)"/>
            <seealso cref="M:MB.WinEIDrive.Excel.CellRange.GetSubrangeRelative(System.Int32,System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:MB.WinEIDrive.Excel.CellRange.GetSubrangeAbsolute(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns new cell range using absolute indexing.
            </summary>
            <param name="firstRow">Absolute index of the first row.</param>
            <param name="firstColumn">Absolute index of the first column.</param>
            <param name="lastRow">Absolute index of the last row.</param>
            <param name="lastColumn">Absolute index of the last column.</param>
            <remarks>
            New cell range must be within this cell range.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if arguments are out of range.</exception>
            <seealso cref="P:MB.WinEIDrive.Excel.CellRange.FirstRowIndex"/>
            <seealso cref="P:MB.WinEIDrive.Excel.CellRange.FirstColumnIndex"/>
            <seealso cref="P:MB.WinEIDrive.Excel.CellRange.LastRowIndex"/>
            <seealso cref="P:MB.WinEIDrive.Excel.CellRange.LastColumnIndex"/>
            <seealso cref="M:MB.WinEIDrive.Excel.CellRange.GetSubrangeRelative(System.Int32,System.Int32,System.Int32,System.Int32)"/>
            <seealso cref="M:MB.WinEIDrive.Excel.CellRange.GetSubrange(System.String,System.String)"/>
        </member>
        <member name="M:MB.WinEIDrive.Excel.CellRange.GetSubrangeRelative(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns new cell range using relative indexing.
            </summary>
            <param name="relativeRow">Relative index of the first row.</param>
            <param name="relativeColumn">Relative index of the first column.</param>
            <param name="width">Width of new cell range in columns.</param>
            <param name="height">Height of new cell range in rows.</param>
            <remarks>
            New cell range must be within this cell range.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if arguments are out of range.</exception>
            <seealso cref="P:MB.WinEIDrive.Excel.CellRange.Width"/>
            <seealso cref="P:MB.WinEIDrive.Excel.CellRange.Height"/>
            <seealso cref="M:MB.WinEIDrive.Excel.CellRange.GetSubrangeAbsolute(System.Int32,System.Int32,System.Int32,System.Int32)"/>
            <seealso cref="M:MB.WinEIDrive.Excel.CellRange.GetSubrange(System.String,System.String)"/>
        </member>
        <member name="M:MB.WinEIDrive.Excel.CellRange.Overlaps(MB.WinEIDrive.Excel.CellRange)">
            <summary>
            Checks if this cell range overlaps with another cell range.
            </summary>
            <param name="range">Cell range.</param>
            <returns><b>true</b> if cell ranges overlap; otherwise, <b>false</b>.</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.CellRange.PositionToRowColumn(System.String,System.Int32@,System.Int32@)">
            <summary>
            Converts position string ("A1", "BN27", etc.) to row and column index.
            </summary>
            <param name="position">Position string.</param>
            <param name="row">Row index.</param>
            <param name="column">Column index.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.CellRange.RowColumnToPosition(System.Int32,System.Int32)">
            <summary>
            Converts row and column index to position string ("A1", "BN27", etc.).
            </summary>
            <param name="row">Row index.</param>
            <param name="column">Column index.</param>
            <returns>Position string.</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.CellRange.SetBorders(MB.WinEIDrive.Excel.MultipleBorders,System.Drawing.Color,MB.WinEIDrive.Excel.LineStyle)">
            <summary>
            Sets borders on one or more excel cells, taking cell position into account.
            </summary>
            <param name="multipleBorders">Borders to set.</param>
            <param name="lineColor">Line color.</param>
            <param name="lineStyle">Line style.</param>
            <example> Following code creates horizontal, vertical and rectangular cell ranges and demonstrates how
            indexing works different in different context. <see cref="M:MB.WinEIDrive.Excel.CellRange.SetBorders(MB.WinEIDrive.Excel.MultipleBorders,System.Drawing.Color,MB.WinEIDrive.Excel.LineStyle)">SetBorders</see>
            method is used to mark outside borders of the rectangular range.
            <code lang="Visual Basic">
            Dim cr As CellRange = excelFile.Worksheets(0).Rows(1).Cells
            
            cr(0).Value = cr.IndexingMode
            cr(3).Value = "D2"
            cr("B").Value = "B2"
            
            cr = excelFile.Worksheets(0).Columns(4).Cells
            
            cr(0).Value = cr.IndexingMode
            cr(2).Value = "E3"
            cr("5").Value = "E5"
            
            cr = excelFile.Worksheets(0).Cells.GetSubrange("F2", "J8")
            cr.SetBorders(MultipleBorders.Outside, Color.Navy, LineStyle.Dashed)
            
            cr("I7").Value = cr.IndexingMode
            cr(0, 0).Value = "F2"
            cr("G3").Value = "G3"
            cr(5).Value = "F3" <font color="Green">' Cell range width is 5 (F G H I J).</font>
            </code>
            <code lang="C#">
            CellRange cr = excelFile.Worksheets[0].Rows[1].Cells;
            
            cr[0].Value = cr.IndexingMode;
            cr[3].Value = "D2";
            cr["B"].Value = "B2";
            
            cr = excelFile.Worksheets[0].Columns[4].Cells;
            
            cr[0].Value = cr.IndexingMode;
            cr[2].Value = "E3";
            cr["5"].Value = "E5";
            
            cr = excelFile.Worksheets[0].Cells.GetSubrange("F2", "J8");
            cr.SetBorders(MultipleBorders.Outside, Color.Navy, LineStyle.Dashed);
            
            cr["I7"].Value = cr.IndexingMode;
            cr[0,0].Value = "F2";
            cr["G3"].Value = "G3";
            cr[5].Value = "F3"; <font color="Green">// Cell range width is 5 (F G H I J).</font>
            </code>
            </example>
        </member>
        <member name="M:MB.WinEIDrive.Excel.CellRange.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:MB.WinEIDrive.Excel.CellRange">CellRange</see>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:MB.WinEIDrive.Excel.CellRange">CellRange</see>.
            </returns>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellRange.EndPosition">
            <summary>
            Gets name of the last (bottom-right) cell in this cell range.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellRange.FirstColumnIndex">
            <summary>
            Gets index of the first (leftmost) column.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellRange.FirstRowIndex">
            <summary>
            Gets index of the first (topmost) row.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellRange.Formula">
            <summary>
            Gets or sets formula string.
            </summary>
            <remarks>
            <p>ExcelLite can read and write formulas, but can not calculate formula results. When you open a XLS file in
            MS Excel, formula results will be calculated automaticaly.</p>
            <p>During setting formula string ExcelLite formula parser will use English culture to parse numbers.</p>
            <p>Currently supported formula features are:
            <list type="bullet">
            <item><description>Named cell</description></item>
            <item><description>Named range</description></item>
            <item><description>Absolute cell/range</description></item>
            <item><description>Relative cell/range</description></item>
            <item><description>Functions( partly, see the list of supported functions below )</description></item>
            <item><description>Missed argument</description></item>
            <item><description>Unary operator</description></item>
            <item><description>Binary operator</description></item>
            <item><description>Parentheses</description></item>
            <item><description>3d cell reference</description></item>
            <item><description>3d cell range reference</description></item>
            <item><description>Boolean</description></item>
            <item><description>Integer</description></item>
            <item><description>Float</description></item>
            <item><description>String</description></item>
            <item><description>Error</description></item>
            </list>
            </p>
            <p>
            Currently unsupported formula features are:
            <list type="bullet">
            <item><description>Const array</description></item>
            <item><description>Array formula</description></item>
            <item><description>R1C1 reference</description></item>
            </list>
            </p>
            <p>
            Currently supported functions are:
            <list type="bullet">
            <item><description>NOW</description></item>
            <item><description>SECOND</description></item>
            <item><description>MINUTE</description></item>
            <item><description>HOUR</description></item>
            <item><description>WEEKDAY</description></item>
            <item><description>YEAR</description></item>
            <item><description>MONTH</description></item>
            <item><description>DAY</description></item>
            <item><description>TIME</description></item>
            <item><description>DATE</description></item>
            <item><description>RAND</description></item>
            <item><description>TEXT</description></item>
            <item><description>VAR</description></item>
            <item><description>MOD</description></item>
            <item><description>NOT</description></item>
            <item><description>OR</description></item>
            <item><description>AND</description></item>
            <item><description>FALSE</description></item>
            <item><description>TRUE</description></item>
            <item><description>VALUE</description></item>
            <item><description>LEN</description></item>
            <item><description>MID</description></item>
            <item><description>ROUND</description></item>
            <item><description>SIGN</description></item>
            <item><description>INT</description></item>
            <item><description>ABS</description></item>
            <item><description>LN</description></item>
            <item><description>EXP</description></item>
            <item><description>SQRT</description></item>
            <item><description>PI</description></item>
            <item><description>COS</description></item>
            <item><description>SIN</description></item>
            <item><description>COLUMN</description></item>
            <item><description>ROW</description></item>
            <item><description>MAX</description></item>
            <item><description>MIN</description></item>
            <item><description>AVERAGE</description></item>
            <item><description>SUM</description></item>
            <item><description>IF</description></item>
            <item><description>COUNT</description></item>
            </list>
            </p>
            <p>
            For more information on formulas, consult Microsoft Excel documentation.
            </p>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if property get is attempted on a cell range
            which is not merged.</exception>
            <example>Following code demonstrates how to use formulas and named ranges. It shows next features:
            cell references (both absolute and relative), unary and binary operators, constand operands (integer and floating point),
            functions and named cell ranges.
            <code lang="Visual Basic">
            ws.Cells("A1").Value = 5
            ws.Cells("A2").Value = 6
            ws.Cells("A3").Value = 10
            
            ws.Cells("C1").Formula = "=A1+A2"
            ws.Cells("C2").Formula = "=$A$1-A3"
            ws.Cells("C3").Formula = "=COUNT(A1:A3)"
            ws.Cells("C4").Formula = "=AVERAGE($A$1:$A$3)"
            ws.Cells("C5").Formula = "=SUM(A1:A3,2,3)"
            ws.Cells("C7").Formula = "= 123 - (-(-(23.5)))"
            
            ws.NamedRanges.Add("DataRange", ws.Cells.GetSubrange("A1", "A3"))
            ws.Cells("C8").Formula = "=MAX(DataRange)"
            
            Dim cr As CellRange = ws.Cells.GetSubrange("B9","C10")
            cr.Merged = True
            cr.Formula = "=A1*25"
            </code>
            <code lang="C#">
            ws.Cells["A1"].Value = 5;
            ws.Cells["A2"].Value = 6;
            ws.Cells["A3"].Value = 10;
            
            ws.Cells["C1"].Formula = "=A1+A2";
            ws.Cells["C2"].Formula = "=$A$1-A3";
            ws.Cells["C3"].Formula = "=COUNT(A1:A3)";
            ws.Cells["C4"].Formula = "=AVERAGE($A$1:$A$3)";
            ws.Cells["C5"].Formula = "=SUM(A1:A3,2,3)";
            ws.Cells["C7"].Formula = "= 123 - (-(-(23.5)))";
            
            ws.NamedRanges.Add("DataRange", ws.Cells.GetSubrange("A1", "A3"));
            ws.Cells["C8"].Formula = "=MAX(DataRange)";
            
            CellRange cr = ws.Cells.GetSubrange("B9", "C10");
            cr.Merged = true;
            cr.Formula = "=A1*25";
            </code>
            </example>
            <seealso cref="M:MB.WinEIDrive.Excel.NamedRangeCollection.Add(System.String,MB.WinEIDrive.Excel.CellRange)">NamedRangeCollection.Add</seealso>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellRange.Height">
            <summary>
            Gets height of this cell range, in rows.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellRange.IndexingMode">
            <summary>
            Gets indexing mode used for cell range.
            </summary>
            <remarks>
            <p>If <see cref="P:MB.WinEIDrive.Excel.CellRange.Height">Height</see> is 1, indexing mode
            is <see cref="F:MB.WinEIDrive.Excel.RangeIndexingMode.Horizontal">Horizontal</see>.</p>
            <p>Otherwise, if <see cref="P:MB.WinEIDrive.Excel.CellRange.Width">Width</see> is 1, indexing mode
            is <see cref="F:MB.WinEIDrive.Excel.RangeIndexingMode.Vertical">Vertical</see>.</p>
            <p>Otherwise, indexing mode is <see cref="F:MB.WinEIDrive.Excel.RangeIndexingMode.Rectangular">
            Rectangular</see>.</p>
            </remarks>
            <example> Following code creates horizontal, vertical and rectangular cell ranges and demonstrates how
            indexing works different in different context. <see cref="M:MB.WinEIDrive.Excel.CellRange.SetBorders(MB.WinEIDrive.Excel.MultipleBorders,System.Drawing.Color,MB.WinEIDrive.Excel.LineStyle)">SetBorders</see>
            method is used to mark outside borders of the rectangular range.
            <code lang="Visual Basic">
            Dim cr As CellRange = excelFile.Worksheets(0).Rows(1).Cells
            
            cr(0).Value = cr.IndexingMode
            cr(3).Value = "D2"
            cr("B").Value = "B2"
            
            cr = excelFile.Worksheets(0).Columns(4).Cells
            
            cr(0).Value = cr.IndexingMode
            cr(2).Value = "E3"
            cr("5").Value = "E5"
            
            cr = excelFile.Worksheets(0).Cells.GetSubrange("F2", "J8")
            cr.SetBorders(MultipleBorders.Outside, Color.Navy, LineStyle.Dashed)
            
            cr("I7").Value = cr.IndexingMode
            cr(0, 0).Value = "F2"
            cr("G3").Value = "G3"
            cr(5).Value = "F3" <font color="Green">' Cell range width is 5 (F G H I J).</font>
            </code>
            <code lang="C#">
            CellRange cr = excelFile.Worksheets[0].Rows[1].Cells;
            
            cr[0].Value = cr.IndexingMode;
            cr[3].Value = "D2";
            cr["B"].Value = "B2";
            
            cr = excelFile.Worksheets[0].Columns[4].Cells;
            
            cr[0].Value = cr.IndexingMode;
            cr[2].Value = "E3";
            cr["5"].Value = "E5";
            
            cr = excelFile.Worksheets[0].Cells.GetSubrange("F2", "J8");
            cr.SetBorders(MultipleBorders.Outside, Color.Navy, LineStyle.Dashed);
            
            cr["I7"].Value = cr.IndexingMode;
            cr[0,0].Value = "F2";
            cr["G3"].Value = "G3";
            cr[5].Value = "F3"; <font color="Green">// Cell range width is 5 (F G H I J).</font>
            </code>
            </example>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellRange.IsAnyCellMerged">
            <summary>
            Returns <b>true</b> is any cell in this cell range is merged; otherwise, <b>false</b>.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellRange.IsStyleDefault">
            <summary>
            Returns <b>true</b> if all cells in cell range or merged range have default
            cell style; otherwise, <b>false</b>.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellRange.Item(System.Int32,System.Int32)">
            <summary>
            Gets excel cell at the specified relative position.
            </summary>
            <param name="relativeRow">The zero-based relative row position.</param>
            <param name="relativeColumn">The zero-based relative column position.</param>
            <remarks>
            Absolute position of excel cell is calculated by adding <i>relativeRow</i> and <i>relativeColumn</i> to
            <see cref="P:MB.WinEIDrive.Excel.CellRange.FirstRowIndex">FirstRowIndex</see> and
            <see cref="P:MB.WinEIDrive.Excel.CellRange.FirstColumnIndex">FirstColumnIndex</see>.
            </remarks>
            <example> Following code creates horizontal, vertical and rectangular cell ranges and demonstrates how
            indexing works different in different context. <see cref="M:MB.WinEIDrive.Excel.CellRange.SetBorders(MB.WinEIDrive.Excel.MultipleBorders,System.Drawing.Color,MB.WinEIDrive.Excel.LineStyle)">SetBorders</see>
            method is used to mark outside borders of the rectangular range.
            <code lang="Visual Basic">
            Dim cr As CellRange = excelFile.Worksheets(0).Rows(1).Cells
            
            cr(0).Value = cr.IndexingMode
            cr(3).Value = "D2"
            cr("B").Value = "B2"
            
            cr = excelFile.Worksheets(0).Columns(4).Cells
            
            cr(0).Value = cr.IndexingMode
            cr(2).Value = "E3"
            cr("5").Value = "E5"
            
            cr = excelFile.Worksheets(0).Cells.GetSubrange("F2", "J8")
            cr.SetBorders(MultipleBorders.Outside, Color.Navy, LineStyle.Dashed)
            
            cr("I7").Value = cr.IndexingMode
            cr(0, 0).Value = "F2"
            cr("G3").Value = "G3"
            cr(5).Value = "F3" <font color="Green">' Cell range width is 5 (F G H I J).</font>
            </code>
            <code lang="C#">
            CellRange cr = excelFile.Worksheets[0].Rows[1].Cells;
            
            cr[0].Value = cr.IndexingMode;
            cr[3].Value = "D2";
            cr["B"].Value = "B2";
            
            cr = excelFile.Worksheets[0].Columns[4].Cells;
            
            cr[0].Value = cr.IndexingMode;
            cr[2].Value = "E3";
            cr["5"].Value = "E5";
            
            cr = excelFile.Worksheets[0].Cells.GetSubrange("F2", "J8");
            cr.SetBorders(MultipleBorders.Outside, Color.Navy, LineStyle.Dashed);
            
            cr["I7"].Value = cr.IndexingMode;
            cr[0,0].Value = "F2";
            cr["G3"].Value = "G3";
            cr[5].Value = "F3"; <font color="Green">// Cell range width is 5 (F G H I J).</font>
            </code>
            </example>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellRange.Item(System.String)">
            <summary>
            Gets excel cell with the specified full or partial name.
            </summary>
            <param name="contextName">Full or partial name of the cell.</param>
            <remarks>
            <p>If <see cref="P:MB.WinEIDrive.Excel.CellRange.IndexingMode">IndexingMode</see> is
            <see cref="F:MB.WinEIDrive.Excel.RangeIndexingMode.Rectangular">RangeIndexingMode.Rectangular</see> full name of
            the cell must be used (for example; "A1", "D7", etc.).</p>
            <p>If <see cref="P:MB.WinEIDrive.Excel.CellRange.IndexingMode">IndexingMode</see> is
            <see cref="F:MB.WinEIDrive.Excel.RangeIndexingMode.Horizontal">RangeIndexingMode.Horizontal</see> column name
            must be used (for example; "A", "D", etc.).</p>
            <p>If <see cref="P:MB.WinEIDrive.Excel.CellRange.IndexingMode">IndexingMode</see> is
            <see cref="F:MB.WinEIDrive.Excel.RangeIndexingMode.Vertical">RangeIndexingMode.Vertical</see> row name
            must be used (for example; "1", "7", etc.).</p>
            </remarks>
            <example> Following code creates horizontal, vertical and rectangular cell ranges and demonstrates how
            indexing works different in different context. <see cref="M:MB.WinEIDrive.Excel.CellRange.SetBorders(MB.WinEIDrive.Excel.MultipleBorders,System.Drawing.Color,MB.WinEIDrive.Excel.LineStyle)">SetBorders</see>
            method is used to mark outside borders of the rectangular range.
            <code lang="Visual Basic">
            Dim cr As CellRange = excelFile.Worksheets(0).Rows(1).Cells
            
            cr(0).Value = cr.IndexingMode
            cr(3).Value = "D2"
            cr("B").Value = "B2"
            
            cr = excelFile.Worksheets(0).Columns(4).Cells
            
            cr(0).Value = cr.IndexingMode
            cr(2).Value = "E3"
            cr("5").Value = "E5"
            
            cr = excelFile.Worksheets(0).Cells.GetSubrange("F2", "J8")
            cr.SetBorders(MultipleBorders.Outside, Color.Navy, LineStyle.Dashed)
            
            cr("I7").Value = cr.IndexingMode
            cr(0, 0).Value = "F2"
            cr("G3").Value = "G3"
            cr(5).Value = "F3" <font color="Green">' Cell range width is 5 (F G H I J).</font>
            </code>
            <code lang="C#">
            CellRange cr = excelFile.Worksheets[0].Rows[1].Cells;
            
            cr[0].Value = cr.IndexingMode;
            cr[3].Value = "D2";
            cr["B"].Value = "B2";
            
            cr = excelFile.Worksheets[0].Columns[4].Cells;
            
            cr[0].Value = cr.IndexingMode;
            cr[2].Value = "E3";
            cr["5"].Value = "E5";
            
            cr = excelFile.Worksheets[0].Cells.GetSubrange("F2", "J8");
            cr.SetBorders(MultipleBorders.Outside, Color.Navy, LineStyle.Dashed);
            
            cr["I7"].Value = cr.IndexingMode;
            cr[0,0].Value = "F2";
            cr["G3"].Value = "G3";
            cr[5].Value = "F3"; <font color="Green">// Cell range width is 5 (F G H I J).</font>
            </code>
            </example>
            <seealso cref="P:MB.WinEIDrive.Excel.CellRange.IndexingMode"/>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellRange.Item(System.Int32)">
            <overloads>Gets excel cell with the specified name or at the specified position.</overloads>
            <summary>
            Gets excel cell at the specified index.
            </summary>
            <param name="contextIndex">The zero-based context index of the cell.</param>
            <remarks>
            <p>If <see cref="P:MB.WinEIDrive.Excel.CellRange.IndexingMode">IndexingMode</see> is
            <see cref="F:MB.WinEIDrive.Excel.RangeIndexingMode.Horizontal">RangeIndexingMode.Horizontal</see> context index
            is specifying relative column position.</p>
            <p>If <see cref="P:MB.WinEIDrive.Excel.CellRange.IndexingMode">IndexingMode</see> is
            <see cref="F:MB.WinEIDrive.Excel.RangeIndexingMode.Vertical">RangeIndexingMode.Vertical</see> context index
            is specifying relative row position.</p>
            <p>If <see cref="P:MB.WinEIDrive.Excel.CellRange.IndexingMode">IndexingMode</see> is
            <see cref="F:MB.WinEIDrive.Excel.RangeIndexingMode.Rectangular">RangeIndexingMode.Rectangular</see> context index
            is specifying cell index inside cell range. The cell at <see cref="P:MB.WinEIDrive.Excel.CellRange.StartPosition">
            StartPosition</see> has index 0, and the cell at
            <see cref="P:MB.WinEIDrive.Excel.CellRange.EndPosition">EndPosition</see> has index of
            <see cref="P:MB.WinEIDrive.Excel.CellRange.Width">Width</see> x
            <see cref="P:MB.WinEIDrive.Excel.CellRange.Height">Height</see> - 1.</p>
            </remarks>
            <example> Following code creates horizontal, vertical and rectangular cell ranges and demonstrates how
            indexing works different in different context. <see cref="M:MB.WinEIDrive.Excel.CellRange.SetBorders(MB.WinEIDrive.Excel.MultipleBorders,System.Drawing.Color,MB.WinEIDrive.Excel.LineStyle)">SetBorders</see>
            method is used to mark outside borders of the rectangular range.
            <code lang="Visual Basic">
            Dim cr As CellRange = excelFile.Worksheets(0).Rows(1).Cells
            
            cr(0).Value = cr.IndexingMode
            cr(3).Value = "D2"
            cr("B").Value = "B2"
            
            cr = excelFile.Worksheets(0).Columns(4).Cells
            
            cr(0).Value = cr.IndexingMode
            cr(2).Value = "E3"
            cr("5").Value = "E5"
            
            cr = excelFile.Worksheets(0).Cells.GetSubrange("F2", "J8")
            cr.SetBorders(MultipleBorders.Outside, Color.Navy, LineStyle.Dashed)
            
            cr("I7").Value = cr.IndexingMode
            cr(0, 0).Value = "F2"
            cr("G3").Value = "G3"
            cr(5).Value = "F3" <font color="Green">' Cell range width is 5 (F G H I J).</font>
            </code>
            <code lang="C#">
            CellRange cr = excelFile.Worksheets[0].Rows[1].Cells;
            
            cr[0].Value = cr.IndexingMode;
            cr[3].Value = "D2";
            cr["B"].Value = "B2";
            
            cr = excelFile.Worksheets[0].Columns[4].Cells;
            
            cr[0].Value = cr.IndexingMode;
            cr[2].Value = "E3";
            cr["5"].Value = "E5";
            
            cr = excelFile.Worksheets[0].Cells.GetSubrange("F2", "J8");
            cr.SetBorders(MultipleBorders.Outside, Color.Navy, LineStyle.Dashed);
            
            cr["I7"].Value = cr.IndexingMode;
            cr[0,0].Value = "F2";
            cr["G3"].Value = "G3";
            cr[5].Value = "F3"; <font color="Green">// Cell range width is 5 (F G H I J).</font>
            </code>
            </example>
            <seealso cref="P:MB.WinEIDrive.Excel.CellRange.IndexingMode"/>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellRange.LastColumnIndex">
            <summary>
            Gets index of the last (rightmost) column.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellRange.LastRowIndex">
            <summary>
            Gets index of the last (bottommost) row.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellRange.Merged">
            <summary>
            Gets or sets whether cells in this range are merged.
            </summary>
            <remarks>
            <p>By setting this property to <b>true</b>, you are merging all the cells
            (<see cref="T:MB.WinEIDrive.Excel.ExcelCell">ExcelCell</see>) in this range. Merging process will fail if any
            of the cells in the range is already merged.</p>
            <p>When modifying merged cell, whole merged range is modified. For example, if you set
            <see cref="P:MB.WinEIDrive.Excel.ExcelCell.Value">ExcelCell.Value</see>, value of merged range will be modified.
            You can find out if the cell is merged by checking if
            <see cref="P:MB.WinEIDrive.Excel.ExcelCell.MergedRange">ExcelCell.MergedRange</see> property is different
            than <b>null</b>.</p>
            </remarks>
            <exception cref="T:System.ArgumentException">Thrown when merged range can't be created because some of the cells
            in the range are already merged.</exception>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellRange.StartPosition">
            <summary>
            Gets name of the first (top-left) cell in this cell range.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellRange.Style">
            <summary>
            Gets or sets cell style (<see cref="T:MB.WinEIDrive.Excel.CellStyle">CellStyle</see>) on one or more excel cells.
            </summary>
            <remarks>
            <p>Property set will set style of multiple cells or of a merged range.</p>
            <p>Property get has meaning only if range is <see cref="P:MB.WinEIDrive.Excel.CellRange.Merged">Merged</see>;
            otherwise, exception is thrown.</p>
            <p> Note that for <see cref="P:MB.WinEIDrive.Excel.CellRange.Style">Style</see> property set on a cell range that
            is not merged, you can't use the following format:
            <code lang="Visual Basic">
            Dim cr As CellRange = excelFile.Worksheets(0).Rows(1).Cells
            cr.Style.Rotation = 30
            </code>
            <code lang="C#">
            CellRange cr = excelFile.Worksheets[0].Rows[1].Cells;
            cr.Style.Rotation = 30;
            </code>
            because that would first call <see cref="P:MB.WinEIDrive.Excel.CellRange.Style">Style</see> property get method and that
            will certainly fail because <see cref="P:MB.WinEIDrive.Excel.CellRange.Style">Style</see> property get is defined only
            for a merged cell range. </p><p>Instead you can use two different code patterns, depending on whether you want to replace or combine the existing
            cell range styles with the new style.</p><p>
            If you want to <b>replace</b> cell style on every cell in a cell range use the following code:
            <code lang="Visual Basic">
            Dim cr As CellRange = excelFile.Worksheets(0).Rows(1).Cells
            Dim style As CellStyle = New CellStyle()
            style.Rotation = 30
            cr.Style = style
            </code>
            <code lang="C#">
            CellRange cr = excelFile.Worksheets[0].Rows[1].Cells;
            CellStyle style = new CellStyle();
            style.Rotation = 30;
            cr.Style = style;
            </code>
            </p><p>
            If you want to <b>set</b> cell style property on every cell in a cell range (other cell style property values will
            remain unchanged) use the following code:
            <code lang="Visual Basic">
            Dim cell As ExcelCell
            For Each cell In excelFile.Worksheets(0).Rows(1).Cells
            cell.Style.Rotation = 30
            Next
            </code>
            <code lang="C#">
            foreach(ExcelCell cell in excelFile.Worksheets[0].Rows[1].Cells)
            cell.Style.Rotation = 30;
            </code>
            </p>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if property get is attempted on a cell range
            which is not merged.</exception>
            <seealso cref="P:MB.WinEIDrive.Excel.CellRange.Merged"/>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellRange.Value">
            <summary>
            Gets or sets cell value on one or more excel cells.
            </summary>
            <remarks>
            <p>Property set will set value of multiple cells or of a merged range.</p>
            <p>Property get has meaning only if range is <see cref="P:MB.WinEIDrive.Excel.CellRange.Merged">Merged</see>;
            otherwise, exception is thrown.</p>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if property get is attempted on a cell range
            which is not merged.</exception>
            <seealso cref="P:MB.WinEIDrive.Excel.CellRange.Merged"/>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellRange.Width">
            <summary>
            Gets width of this cell range, in columns.
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.Excel.CellRangeEnumerator">
            <summary>
            Enumerator used for iterating cells in a <see cref="T:MB.WinEIDrive.Excel.CellRange">CellRange</see>.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.CellRangeEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the cell range.
            </summary>
            <returns>
            <b>true</b> if the enumerator was successfully advanced to the next element; <b>false</b> if
            the enumerator has passed the end of the cell range.
            </returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.CellRangeEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is one column before
            the first cell in the cell range.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellRangeEnumerator.Current">
            <summary>
            Gets the current element in the cell range.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellRangeEnumerator.CurrentCell">
            <summary>
            Gets the current <see cref="T:MB.WinEIDrive.Excel.ExcelCell">ExcelCell</see> in the cell range.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellRangeEnumerator.CurrentColumn">
            <summary>
            Current absolute column index in the cell range.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellRangeEnumerator.CurrentRow">
            <summary>
            Current absolute row index in the cell range.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellRangeEnumerator.Parent">
            <summary>
            Parent <see cref="T:MB.WinEIDrive.Excel.CellRange">CellRange</see>.
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.Excel.CellStyle">
            <summary>
            Contains settings specifying how the cell data will be displayed.
            </summary>
            <remarks>
            Various settings control various display aspects: alignment, patterns and shading, indentation,
            rotation, cell protection, text wrapping, number format, font related settings and cell borders. You can
            set cell style of a specific Excel through its <b>Style</b> property, or you can create new cell style
            with desired properties and apply it to unlimited number of Excel objects. Note, however, that number of
            distinct cell styles in Excel file can't exceed <see cref="F:MB.WinEIDrive.Excel.ExcelFile.MaxCellStyles">
            ExcelFile.MaxCellStyles</see>. You don't have to worry about creating duplicate cell styles; internal
            caching engine will eliminate duplicates in appropriate moments.
            </remarks>
            <example> Following code demonstrates various cell style properties:
            <code lang="Visual Basic">
            Sub StylesSample(ByVal ws As ExcelWorksheet)
            ws.Cells(0, 0).Value = "Cell style examples:"
            
            Dim row As Integer = 0
            
            <font color="Green">' Column width of 4, 30 and 35 characters.</font>
            ws.Columns(0).Width = 4 * 256
            ws.Columns(1).Width = 30 * 256
            ws.Columns(2).Width = 35 * 256
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Borders.SetBorders(...)"
            ws.Cells(row, 2).Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin)
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.FillPattern.SetPattern(...)"
            ws.Cells(row, 2).Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow)
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Color ="
            ws.Cells(row, 2).Value = "Color.Blue"
            ws.Cells(row, 2).Style.Font.Color = Color.Blue
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Italic ="
            ws.Cells(row, 2).Value = "true"
            ws.Cells(row, 2).Style.Font.Italic = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Name ="
            ws.Cells(row, 2).Value = "Comic Sans MS"
            ws.Cells(row, 2).Style.Font.Name = "Comic Sans MS"
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.ScriptPosition ="
            ws.Cells(row, 2).Value = "ScriptPosition.Superscript"
            ws.Cells(row, 2).Style.Font.ScriptPosition = ScriptPosition.Superscript
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Size ="
            ws.Cells(row, 2).Value = "18 * 20"
            ws.Cells(row, 2).Style.Font.Size = 18 * 20
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Strikeout ="
            ws.Cells(row, 2).Value = "true"
            ws.Cells(row, 2).Style.Font.Strikeout = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.UnderlineStyle ="
            ws.Cells(row, 2).Value = "UnderlineStyle.Double"
            ws.Cells(row, 2).Style.Font.UnderlineStyle = UnderlineStyle.Double
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Weight ="
            ws.Cells(row, 2).Value = "ExcelFont.BoldWeight"
            ws.Cells(row, 2).Style.Font.Weight = ExcelFont.BoldWeight
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.HorizontalAlignment ="
            ws.Cells(row, 2).Value = "HorizontalAlignmentStyle.Center"
            ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Center
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Indent"
            ws.Cells(row, 2).Value = "five"
            ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Left
            ws.Cells(row, 2).Style.Indent = 5
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.IsTextVertical = "
            ws.Cells(row, 2).Value = "true"
            <font color="Green">' Set row height to 50 points.</font>
            ws.Rows(row).Height = 50 * 20
            ws.Cells(row, 2).Style.IsTextVertical = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.NumberFormat"
            ws.Cells(row, 2).Value = 1234
            ws.Cells(row, 2).Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]"
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Rotation"
            ws.Cells(row, 2).Value = "35 degrees up"
            ws.Cells(row, 2).Style.Rotation = 35
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.ShrinkToFit"
            ws.Cells(row, 2).Value = "This property is set to true so this text appears shrunk."
            ws.Cells(row, 2).Style.ShrinkToFit = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.VerticalAlignment ="
            ws.Cells(row, 2).Value = "VerticalAlignmentStyle.Top"
            <font color="Green">' Set row height to 30 points.</font>
            ws.Rows(row).Height = 30 * 20
            ws.Cells(row, 2).Style.VerticalAlignment = VerticalAlignmentStyle.Top
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.WrapText"
            ws.Cells(row, 2).Value = "This property is set to true so this text appears broken into multiple lines."
            ws.Cells(row, 2).Style.WrapText = True
            End Sub
            </code>
            <code lang="C#">
            static void StylesSample(ExcelWorksheet ws)
            {
            ws.Cells[0,0].Value = "Cell style examples:";
            
            int row = 0;
            
            <font color="Green">// Column width of 4, 30 and 35 characters.</font>
            ws.Columns[0].Width = 4 * 256;
            ws.Columns[1].Width = 30 * 256;
            ws.Columns[2].Width = 35 * 256;
            
            ws.Cells[row+=2,1].Value = ".Style.Borders.SetBorders(...)";
            ws.Cells[row,2].Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin);
            
            ws.Cells[row+=2,1].Value = ".Style.FillPattern.SetPattern(...)";
            ws.Cells[row,2].Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow);
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Color =";
            ws.Cells[row,2].Value = "Color.Blue";
            ws.Cells[row,2].Style.Font.Color = Color.Blue;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Italic =";
            ws.Cells[row,2].Value = "true";
            ws.Cells[row,2].Style.Font.Italic = true;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Name =";
            ws.Cells[row,2].Value = "Comic Sans MS";
            ws.Cells[row,2].Style.Font.Name = "Comic Sans MS";
            
            ws.Cells[row+=2,1].Value = ".Style.Font.ScriptPosition =";
            ws.Cells[row,2].Value = "ScriptPosition.Superscript";
            ws.Cells[row,2].Style.Font.ScriptPosition = ScriptPosition.Superscript;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Size =";
            ws.Cells[row,2].Value = "18 * 20";
            ws.Cells[row,2].Style.Font.Size = 18 * 20;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Strikeout =";
            ws.Cells[row,2].Value = "true";
            ws.Cells[row,2].Style.Font.Strikeout = true;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.UnderlineStyle =";
            ws.Cells[row,2].Value = "UnderlineStyle.Double";
            ws.Cells[row,2].Style.Font.UnderlineStyle = UnderlineStyle.Double;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Weight =";
            ws.Cells[row,2].Value = "ExcelFont.BoldWeight";
            ws.Cells[row,2].Style.Font.Weight = ExcelFont.BoldWeight;
            
            ws.Cells[row+=2,1].Value = ".Style.HorizontalAlignment =";
            ws.Cells[row,2].Value = "HorizontalAlignmentStyle.Center";
            ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Center;
            
            ws.Cells[row+=2,1].Value = ".Style.Indent";
            ws.Cells[row,2].Value = "five";
            ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Left;
            ws.Cells[row,2].Style.Indent = 5;
            
            ws.Cells[row+=2,1].Value = ".Style.IsTextVertical = ";
            ws.Cells[row,2].Value = "true";
            <font color="Green">// Set row height to 50 points.</font>
            ws.Rows[row].Height = 50 * 20;
            ws.Cells[row,2].Style.IsTextVertical = true;
            
            ws.Cells[row+=2,1].Value = ".Style.NumberFormat";
            ws.Cells[row,2].Value = 1234;
            ws.Cells[row,2].Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]";
            
            ws.Cells[row+=2,1].Value = ".Style.Rotation";
            ws.Cells[row,2].Value = "35 degrees up";
            ws.Cells[row,2].Style.Rotation = 35;
            
            ws.Cells[row+=2,1].Value = ".Style.ShrinkToFit";
            ws.Cells[row,2].Value = "This property is set to true so this text appears shrunk.";
            ws.Cells[row,2].Style.ShrinkToFit = true;
            
            ws.Cells[row+=2,1].Value = ".Style.VerticalAlignment =";
            ws.Cells[row,2].Value = "VerticalAlignmentStyle.Top";
            <font color="Green">// Set row height to 30 points.</font>
            ws.Rows[row].Height = 30 * 20;
            ws.Cells[row,2].Style.VerticalAlignment = VerticalAlignmentStyle.Top;
            
            ws.Cells[row+=2,1].Value = ".Style.WrapText";
            ws.Cells[row,2].Value = "This property is set to true so this text appears broken into multiple lines.";
            ws.Cells[row,2].Style.WrapText = true;
            }
            </code>
            </example>
        </member>
        <member name="M:MB.WinEIDrive.Excel.CellStyle.#ctor">
            <summary>
            Creates new cell style with default values.
            </summary>
            <remarks>
            Creating standalone cell style has sense only if you assign it to some Excel objects
            by setting <b>Style</b> property. Otherwise, the created cell style will have no effect on the Excel file.
            </remarks>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellStyle.Borders">
            <summary>
            Gets or sets cell borders (<see cref="T:MB.WinEIDrive.Excel.CellBorder">CellBorder</see>).
            </summary>
            <example> Following code demonstrates various cell style properties:
            <code lang="Visual Basic">
            Sub StylesSample(ByVal ws As ExcelWorksheet)
            ws.Cells(0, 0).Value = "Cell style examples:"
            
            Dim row As Integer = 0
            
            <font color="Green">' Column width of 4, 30 and 35 characters.</font>
            ws.Columns(0).Width = 4 * 256
            ws.Columns(1).Width = 30 * 256
            ws.Columns(2).Width = 35 * 256
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Borders.SetBorders(...)"
            ws.Cells(row, 2).Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin)
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.FillPattern.SetPattern(...)"
            ws.Cells(row, 2).Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow)
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Color ="
            ws.Cells(row, 2).Value = "Color.Blue"
            ws.Cells(row, 2).Style.Font.Color = Color.Blue
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Italic ="
            ws.Cells(row, 2).Value = "true"
            ws.Cells(row, 2).Style.Font.Italic = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Name ="
            ws.Cells(row, 2).Value = "Comic Sans MS"
            ws.Cells(row, 2).Style.Font.Name = "Comic Sans MS"
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.ScriptPosition ="
            ws.Cells(row, 2).Value = "ScriptPosition.Superscript"
            ws.Cells(row, 2).Style.Font.ScriptPosition = ScriptPosition.Superscript
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Size ="
            ws.Cells(row, 2).Value = "18 * 20"
            ws.Cells(row, 2).Style.Font.Size = 18 * 20
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Strikeout ="
            ws.Cells(row, 2).Value = "true"
            ws.Cells(row, 2).Style.Font.Strikeout = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.UnderlineStyle ="
            ws.Cells(row, 2).Value = "UnderlineStyle.Double"
            ws.Cells(row, 2).Style.Font.UnderlineStyle = UnderlineStyle.Double
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Weight ="
            ws.Cells(row, 2).Value = "ExcelFont.BoldWeight"
            ws.Cells(row, 2).Style.Font.Weight = ExcelFont.BoldWeight
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.HorizontalAlignment ="
            ws.Cells(row, 2).Value = "HorizontalAlignmentStyle.Center"
            ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Center
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Indent"
            ws.Cells(row, 2).Value = "five"
            ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Left
            ws.Cells(row, 2).Style.Indent = 5
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.IsTextVertical = "
            ws.Cells(row, 2).Value = "true"
            <font color="Green">' Set row height to 50 points.</font>
            ws.Rows(row).Height = 50 * 20
            ws.Cells(row, 2).Style.IsTextVertical = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.NumberFormat"
            ws.Cells(row, 2).Value = 1234
            ws.Cells(row, 2).Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]"
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Rotation"
            ws.Cells(row, 2).Value = "35 degrees up"
            ws.Cells(row, 2).Style.Rotation = 35
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.ShrinkToFit"
            ws.Cells(row, 2).Value = "This property is set to true so this text appears shrunk."
            ws.Cells(row, 2).Style.ShrinkToFit = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.VerticalAlignment ="
            ws.Cells(row, 2).Value = "VerticalAlignmentStyle.Top"
            <font color="Green">' Set row height to 30 points.</font>
            ws.Rows(row).Height = 30 * 20
            ws.Cells(row, 2).Style.VerticalAlignment = VerticalAlignmentStyle.Top
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.WrapText"
            ws.Cells(row, 2).Value = "This property is set to true so this text appears broken into multiple lines."
            ws.Cells(row, 2).Style.WrapText = True
            End Sub
            </code>
            <code lang="C#">
            static void StylesSample(ExcelWorksheet ws)
            {
            ws.Cells[0,0].Value = "Cell style examples:";
            
            int row = 0;
            
            <font color="Green">// Column width of 4, 30 and 35 characters.</font>
            ws.Columns[0].Width = 4 * 256;
            ws.Columns[1].Width = 30 * 256;
            ws.Columns[2].Width = 35 * 256;
            
            ws.Cells[row+=2,1].Value = ".Style.Borders.SetBorders(...)";
            ws.Cells[row,2].Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin);
            
            ws.Cells[row+=2,1].Value = ".Style.FillPattern.SetPattern(...)";
            ws.Cells[row,2].Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow);
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Color =";
            ws.Cells[row,2].Value = "Color.Blue";
            ws.Cells[row,2].Style.Font.Color = Color.Blue;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Italic =";
            ws.Cells[row,2].Value = "true";
            ws.Cells[row,2].Style.Font.Italic = true;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Name =";
            ws.Cells[row,2].Value = "Comic Sans MS";
            ws.Cells[row,2].Style.Font.Name = "Comic Sans MS";
            
            ws.Cells[row+=2,1].Value = ".Style.Font.ScriptPosition =";
            ws.Cells[row,2].Value = "ScriptPosition.Superscript";
            ws.Cells[row,2].Style.Font.ScriptPosition = ScriptPosition.Superscript;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Size =";
            ws.Cells[row,2].Value = "18 * 20";
            ws.Cells[row,2].Style.Font.Size = 18 * 20;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Strikeout =";
            ws.Cells[row,2].Value = "true";
            ws.Cells[row,2].Style.Font.Strikeout = true;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.UnderlineStyle =";
            ws.Cells[row,2].Value = "UnderlineStyle.Double";
            ws.Cells[row,2].Style.Font.UnderlineStyle = UnderlineStyle.Double;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Weight =";
            ws.Cells[row,2].Value = "ExcelFont.BoldWeight";
            ws.Cells[row,2].Style.Font.Weight = ExcelFont.BoldWeight;
            
            ws.Cells[row+=2,1].Value = ".Style.HorizontalAlignment =";
            ws.Cells[row,2].Value = "HorizontalAlignmentStyle.Center";
            ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Center;
            
            ws.Cells[row+=2,1].Value = ".Style.Indent";
            ws.Cells[row,2].Value = "five";
            ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Left;
            ws.Cells[row,2].Style.Indent = 5;
            
            ws.Cells[row+=2,1].Value = ".Style.IsTextVertical = ";
            ws.Cells[row,2].Value = "true";
            <font color="Green">// Set row height to 50 points.</font>
            ws.Rows[row].Height = 50 * 20;
            ws.Cells[row,2].Style.IsTextVertical = true;
            
            ws.Cells[row+=2,1].Value = ".Style.NumberFormat";
            ws.Cells[row,2].Value = 1234;
            ws.Cells[row,2].Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]";
            
            ws.Cells[row+=2,1].Value = ".Style.Rotation";
            ws.Cells[row,2].Value = "35 degrees up";
            ws.Cells[row,2].Style.Rotation = 35;
            
            ws.Cells[row+=2,1].Value = ".Style.ShrinkToFit";
            ws.Cells[row,2].Value = "This property is set to true so this text appears shrunk.";
            ws.Cells[row,2].Style.ShrinkToFit = true;
            
            ws.Cells[row+=2,1].Value = ".Style.VerticalAlignment =";
            ws.Cells[row,2].Value = "VerticalAlignmentStyle.Top";
            <font color="Green">// Set row height to 30 points.</font>
            ws.Rows[row].Height = 30 * 20;
            ws.Cells[row,2].Style.VerticalAlignment = VerticalAlignmentStyle.Top;
            
            ws.Cells[row+=2,1].Value = ".Style.WrapText";
            ws.Cells[row,2].Value = "This property is set to true so this text appears broken into multiple lines.";
            ws.Cells[row,2].Style.WrapText = true;
            }
            </code>
            </example>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellStyle.FillPattern">
            <summary>
            Get or sets fill pattern.
            </summary>
            <example> Following code demonstrates various cell style properties:
            <code lang="Visual Basic">
            Sub StylesSample(ByVal ws As ExcelWorksheet)
            ws.Cells(0, 0).Value = "Cell style examples:"
            
            Dim row As Integer = 0
            
            <font color="Green">' Column width of 4, 30 and 35 characters.</font>
            ws.Columns(0).Width = 4 * 256
            ws.Columns(1).Width = 30 * 256
            ws.Columns(2).Width = 35 * 256
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Borders.SetBorders(...)"
            ws.Cells(row, 2).Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin)
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.FillPattern.SetPattern(...)"
            ws.Cells(row, 2).Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow)
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Color ="
            ws.Cells(row, 2).Value = "Color.Blue"
            ws.Cells(row, 2).Style.Font.Color = Color.Blue
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Italic ="
            ws.Cells(row, 2).Value = "true"
            ws.Cells(row, 2).Style.Font.Italic = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Name ="
            ws.Cells(row, 2).Value = "Comic Sans MS"
            ws.Cells(row, 2).Style.Font.Name = "Comic Sans MS"
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.ScriptPosition ="
            ws.Cells(row, 2).Value = "ScriptPosition.Superscript"
            ws.Cells(row, 2).Style.Font.ScriptPosition = ScriptPosition.Superscript
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Size ="
            ws.Cells(row, 2).Value = "18 * 20"
            ws.Cells(row, 2).Style.Font.Size = 18 * 20
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Strikeout ="
            ws.Cells(row, 2).Value = "true"
            ws.Cells(row, 2).Style.Font.Strikeout = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.UnderlineStyle ="
            ws.Cells(row, 2).Value = "UnderlineStyle.Double"
            ws.Cells(row, 2).Style.Font.UnderlineStyle = UnderlineStyle.Double
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Weight ="
            ws.Cells(row, 2).Value = "ExcelFont.BoldWeight"
            ws.Cells(row, 2).Style.Font.Weight = ExcelFont.BoldWeight
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.HorizontalAlignment ="
            ws.Cells(row, 2).Value = "HorizontalAlignmentStyle.Center"
            ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Center
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Indent"
            ws.Cells(row, 2).Value = "five"
            ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Left
            ws.Cells(row, 2).Style.Indent = 5
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.IsTextVertical = "
            ws.Cells(row, 2).Value = "true"
            <font color="Green">' Set row height to 50 points.</font>
            ws.Rows(row).Height = 50 * 20
            ws.Cells(row, 2).Style.IsTextVertical = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.NumberFormat"
            ws.Cells(row, 2).Value = 1234
            ws.Cells(row, 2).Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]"
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Rotation"
            ws.Cells(row, 2).Value = "35 degrees up"
            ws.Cells(row, 2).Style.Rotation = 35
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.ShrinkToFit"
            ws.Cells(row, 2).Value = "This property is set to true so this text appears shrunk."
            ws.Cells(row, 2).Style.ShrinkToFit = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.VerticalAlignment ="
            ws.Cells(row, 2).Value = "VerticalAlignmentStyle.Top"
            <font color="Green">' Set row height to 30 points.</font>
            ws.Rows(row).Height = 30 * 20
            ws.Cells(row, 2).Style.VerticalAlignment = VerticalAlignmentStyle.Top
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.WrapText"
            ws.Cells(row, 2).Value = "This property is set to true so this text appears broken into multiple lines."
            ws.Cells(row, 2).Style.WrapText = True
            End Sub
            </code>
            <code lang="C#">
            static void StylesSample(ExcelWorksheet ws)
            {
            ws.Cells[0,0].Value = "Cell style examples:";
            
            int row = 0;
            
            <font color="Green">// Column width of 4, 30 and 35 characters.</font>
            ws.Columns[0].Width = 4 * 256;
            ws.Columns[1].Width = 30 * 256;
            ws.Columns[2].Width = 35 * 256;
            
            ws.Cells[row+=2,1].Value = ".Style.Borders.SetBorders(...)";
            ws.Cells[row,2].Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin);
            
            ws.Cells[row+=2,1].Value = ".Style.FillPattern.SetPattern(...)";
            ws.Cells[row,2].Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow);
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Color =";
            ws.Cells[row,2].Value = "Color.Blue";
            ws.Cells[row,2].Style.Font.Color = Color.Blue;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Italic =";
            ws.Cells[row,2].Value = "true";
            ws.Cells[row,2].Style.Font.Italic = true;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Name =";
            ws.Cells[row,2].Value = "Comic Sans MS";
            ws.Cells[row,2].Style.Font.Name = "Comic Sans MS";
            
            ws.Cells[row+=2,1].Value = ".Style.Font.ScriptPosition =";
            ws.Cells[row,2].Value = "ScriptPosition.Superscript";
            ws.Cells[row,2].Style.Font.ScriptPosition = ScriptPosition.Superscript;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Size =";
            ws.Cells[row,2].Value = "18 * 20";
            ws.Cells[row,2].Style.Font.Size = 18 * 20;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Strikeout =";
            ws.Cells[row,2].Value = "true";
            ws.Cells[row,2].Style.Font.Strikeout = true;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.UnderlineStyle =";
            ws.Cells[row,2].Value = "UnderlineStyle.Double";
            ws.Cells[row,2].Style.Font.UnderlineStyle = UnderlineStyle.Double;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Weight =";
            ws.Cells[row,2].Value = "ExcelFont.BoldWeight";
            ws.Cells[row,2].Style.Font.Weight = ExcelFont.BoldWeight;
            
            ws.Cells[row+=2,1].Value = ".Style.HorizontalAlignment =";
            ws.Cells[row,2].Value = "HorizontalAlignmentStyle.Center";
            ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Center;
            
            ws.Cells[row+=2,1].Value = ".Style.Indent";
            ws.Cells[row,2].Value = "five";
            ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Left;
            ws.Cells[row,2].Style.Indent = 5;
            
            ws.Cells[row+=2,1].Value = ".Style.IsTextVertical = ";
            ws.Cells[row,2].Value = "true";
            <font color="Green">// Set row height to 50 points.</font>
            ws.Rows[row].Height = 50 * 20;
            ws.Cells[row,2].Style.IsTextVertical = true;
            
            ws.Cells[row+=2,1].Value = ".Style.NumberFormat";
            ws.Cells[row,2].Value = 1234;
            ws.Cells[row,2].Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]";
            
            ws.Cells[row+=2,1].Value = ".Style.Rotation";
            ws.Cells[row,2].Value = "35 degrees up";
            ws.Cells[row,2].Style.Rotation = 35;
            
            ws.Cells[row+=2,1].Value = ".Style.ShrinkToFit";
            ws.Cells[row,2].Value = "This property is set to true so this text appears shrunk.";
            ws.Cells[row,2].Style.ShrinkToFit = true;
            
            ws.Cells[row+=2,1].Value = ".Style.VerticalAlignment =";
            ws.Cells[row,2].Value = "VerticalAlignmentStyle.Top";
            <font color="Green">// Set row height to 30 points.</font>
            ws.Rows[row].Height = 30 * 20;
            ws.Cells[row,2].Style.VerticalAlignment = VerticalAlignmentStyle.Top;
            
            ws.Cells[row+=2,1].Value = ".Style.WrapText";
            ws.Cells[row,2].Value = "This property is set to true so this text appears broken into multiple lines.";
            ws.Cells[row,2].Style.WrapText = true;
            }
            </code>
            </example>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellStyle.Font">
            <summary>
            Gets or sets font related settings.
            </summary>
            <example> Following code demonstrates various cell style properties:
            <code lang="Visual Basic">
            Sub StylesSample(ByVal ws As ExcelWorksheet)
            ws.Cells(0, 0).Value = "Cell style examples:"
            
            Dim row As Integer = 0
            
            <font color="Green">' Column width of 4, 30 and 35 characters.</font>
            ws.Columns(0).Width = 4 * 256
            ws.Columns(1).Width = 30 * 256
            ws.Columns(2).Width = 35 * 256
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Borders.SetBorders(...)"
            ws.Cells(row, 2).Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin)
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.FillPattern.SetPattern(...)"
            ws.Cells(row, 2).Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow)
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Color ="
            ws.Cells(row, 2).Value = "Color.Blue"
            ws.Cells(row, 2).Style.Font.Color = Color.Blue
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Italic ="
            ws.Cells(row, 2).Value = "true"
            ws.Cells(row, 2).Style.Font.Italic = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Name ="
            ws.Cells(row, 2).Value = "Comic Sans MS"
            ws.Cells(row, 2).Style.Font.Name = "Comic Sans MS"
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.ScriptPosition ="
            ws.Cells(row, 2).Value = "ScriptPosition.Superscript"
            ws.Cells(row, 2).Style.Font.ScriptPosition = ScriptPosition.Superscript
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Size ="
            ws.Cells(row, 2).Value = "18 * 20"
            ws.Cells(row, 2).Style.Font.Size = 18 * 20
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Strikeout ="
            ws.Cells(row, 2).Value = "true"
            ws.Cells(row, 2).Style.Font.Strikeout = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.UnderlineStyle ="
            ws.Cells(row, 2).Value = "UnderlineStyle.Double"
            ws.Cells(row, 2).Style.Font.UnderlineStyle = UnderlineStyle.Double
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Weight ="
            ws.Cells(row, 2).Value = "ExcelFont.BoldWeight"
            ws.Cells(row, 2).Style.Font.Weight = ExcelFont.BoldWeight
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.HorizontalAlignment ="
            ws.Cells(row, 2).Value = "HorizontalAlignmentStyle.Center"
            ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Center
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Indent"
            ws.Cells(row, 2).Value = "five"
            ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Left
            ws.Cells(row, 2).Style.Indent = 5
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.IsTextVertical = "
            ws.Cells(row, 2).Value = "true"
            <font color="Green">' Set row height to 50 points.</font>
            ws.Rows(row).Height = 50 * 20
            ws.Cells(row, 2).Style.IsTextVertical = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.NumberFormat"
            ws.Cells(row, 2).Value = 1234
            ws.Cells(row, 2).Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]"
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Rotation"
            ws.Cells(row, 2).Value = "35 degrees up"
            ws.Cells(row, 2).Style.Rotation = 35
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.ShrinkToFit"
            ws.Cells(row, 2).Value = "This property is set to true so this text appears shrunk."
            ws.Cells(row, 2).Style.ShrinkToFit = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.VerticalAlignment ="
            ws.Cells(row, 2).Value = "VerticalAlignmentStyle.Top"
            <font color="Green">' Set row height to 30 points.</font>
            ws.Rows(row).Height = 30 * 20
            ws.Cells(row, 2).Style.VerticalAlignment = VerticalAlignmentStyle.Top
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.WrapText"
            ws.Cells(row, 2).Value = "This property is set to true so this text appears broken into multiple lines."
            ws.Cells(row, 2).Style.WrapText = True
            End Sub
            </code>
            <code lang="C#">
            static void StylesSample(ExcelWorksheet ws)
            {
            ws.Cells[0,0].Value = "Cell style examples:";
            
            int row = 0;
            
            <font color="Green">// Column width of 4, 30 and 35 characters.</font>
            ws.Columns[0].Width = 4 * 256;
            ws.Columns[1].Width = 30 * 256;
            ws.Columns[2].Width = 35 * 256;
            
            ws.Cells[row+=2,1].Value = ".Style.Borders.SetBorders(...)";
            ws.Cells[row,2].Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin);
            
            ws.Cells[row+=2,1].Value = ".Style.FillPattern.SetPattern(...)";
            ws.Cells[row,2].Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow);
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Color =";
            ws.Cells[row,2].Value = "Color.Blue";
            ws.Cells[row,2].Style.Font.Color = Color.Blue;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Italic =";
            ws.Cells[row,2].Value = "true";
            ws.Cells[row,2].Style.Font.Italic = true;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Name =";
            ws.Cells[row,2].Value = "Comic Sans MS";
            ws.Cells[row,2].Style.Font.Name = "Comic Sans MS";
            
            ws.Cells[row+=2,1].Value = ".Style.Font.ScriptPosition =";
            ws.Cells[row,2].Value = "ScriptPosition.Superscript";
            ws.Cells[row,2].Style.Font.ScriptPosition = ScriptPosition.Superscript;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Size =";
            ws.Cells[row,2].Value = "18 * 20";
            ws.Cells[row,2].Style.Font.Size = 18 * 20;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Strikeout =";
            ws.Cells[row,2].Value = "true";
            ws.Cells[row,2].Style.Font.Strikeout = true;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.UnderlineStyle =";
            ws.Cells[row,2].Value = "UnderlineStyle.Double";
            ws.Cells[row,2].Style.Font.UnderlineStyle = UnderlineStyle.Double;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Weight =";
            ws.Cells[row,2].Value = "ExcelFont.BoldWeight";
            ws.Cells[row,2].Style.Font.Weight = ExcelFont.BoldWeight;
            
            ws.Cells[row+=2,1].Value = ".Style.HorizontalAlignment =";
            ws.Cells[row,2].Value = "HorizontalAlignmentStyle.Center";
            ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Center;
            
            ws.Cells[row+=2,1].Value = ".Style.Indent";
            ws.Cells[row,2].Value = "five";
            ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Left;
            ws.Cells[row,2].Style.Indent = 5;
            
            ws.Cells[row+=2,1].Value = ".Style.IsTextVertical = ";
            ws.Cells[row,2].Value = "true";
            <font color="Green">// Set row height to 50 points.</font>
            ws.Rows[row].Height = 50 * 20;
            ws.Cells[row,2].Style.IsTextVertical = true;
            
            ws.Cells[row+=2,1].Value = ".Style.NumberFormat";
            ws.Cells[row,2].Value = 1234;
            ws.Cells[row,2].Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]";
            
            ws.Cells[row+=2,1].Value = ".Style.Rotation";
            ws.Cells[row,2].Value = "35 degrees up";
            ws.Cells[row,2].Style.Rotation = 35;
            
            ws.Cells[row+=2,1].Value = ".Style.ShrinkToFit";
            ws.Cells[row,2].Value = "This property is set to true so this text appears shrunk.";
            ws.Cells[row,2].Style.ShrinkToFit = true;
            
            ws.Cells[row+=2,1].Value = ".Style.VerticalAlignment =";
            ws.Cells[row,2].Value = "VerticalAlignmentStyle.Top";
            <font color="Green">// Set row height to 30 points.</font>
            ws.Rows[row].Height = 30 * 20;
            ws.Cells[row,2].Style.VerticalAlignment = VerticalAlignmentStyle.Top;
            
            ws.Cells[row+=2,1].Value = ".Style.WrapText";
            ws.Cells[row,2].Value = "This property is set to true so this text appears broken into multiple lines.";
            ws.Cells[row,2].Style.WrapText = true;
            }
            </code>
            </example>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellStyle.FormulaHidden">
            <summary>
            Gets or sets whether the formula is hidden in the formula bar when the cell is selected.
            </summary>
            <remarks>
            <p>This property has meaning only if <see cref="P:MB.WinEIDrive.Excel.ExcelFile.Protected">ExcelFile.Protected</see>
            is set to <b>true</b>. For more information consult Microsoft Excel documentation.</p>
            <p>Default value for this property is <b>false</b>.</p>
            </remarks>
            <seealso cref="P:MB.WinEIDrive.Excel.ExcelFile.Protected">ExcelFile.Protected</seealso>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellStyle.HorizontalAlignment">
            <summary>
            Gets or sets horizontal alignment.
            </summary>
            <remarks>
            Default value for this property is <see cref="F:MB.WinEIDrive.Excel.HorizontalAlignmentStyle.General">
            HorizontalAlignmentStyle.General</see>.
            </remarks>
            <example> Following code demonstrates various cell style properties:
            <code lang="Visual Basic">
            Sub StylesSample(ByVal ws As ExcelWorksheet)
            ws.Cells(0, 0).Value = "Cell style examples:"
            
            Dim row As Integer = 0
            
            <font color="Green">' Column width of 4, 30 and 35 characters.</font>
            ws.Columns(0).Width = 4 * 256
            ws.Columns(1).Width = 30 * 256
            ws.Columns(2).Width = 35 * 256
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Borders.SetBorders(...)"
            ws.Cells(row, 2).Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin)
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.FillPattern.SetPattern(...)"
            ws.Cells(row, 2).Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow)
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Color ="
            ws.Cells(row, 2).Value = "Color.Blue"
            ws.Cells(row, 2).Style.Font.Color = Color.Blue
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Italic ="
            ws.Cells(row, 2).Value = "true"
            ws.Cells(row, 2).Style.Font.Italic = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Name ="
            ws.Cells(row, 2).Value = "Comic Sans MS"
            ws.Cells(row, 2).Style.Font.Name = "Comic Sans MS"
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.ScriptPosition ="
            ws.Cells(row, 2).Value = "ScriptPosition.Superscript"
            ws.Cells(row, 2).Style.Font.ScriptPosition = ScriptPosition.Superscript
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Size ="
            ws.Cells(row, 2).Value = "18 * 20"
            ws.Cells(row, 2).Style.Font.Size = 18 * 20
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Strikeout ="
            ws.Cells(row, 2).Value = "true"
            ws.Cells(row, 2).Style.Font.Strikeout = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.UnderlineStyle ="
            ws.Cells(row, 2).Value = "UnderlineStyle.Double"
            ws.Cells(row, 2).Style.Font.UnderlineStyle = UnderlineStyle.Double
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Weight ="
            ws.Cells(row, 2).Value = "ExcelFont.BoldWeight"
            ws.Cells(row, 2).Style.Font.Weight = ExcelFont.BoldWeight
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.HorizontalAlignment ="
            ws.Cells(row, 2).Value = "HorizontalAlignmentStyle.Center"
            ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Center
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Indent"
            ws.Cells(row, 2).Value = "five"
            ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Left
            ws.Cells(row, 2).Style.Indent = 5
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.IsTextVertical = "
            ws.Cells(row, 2).Value = "true"
            <font color="Green">' Set row height to 50 points.</font>
            ws.Rows(row).Height = 50 * 20
            ws.Cells(row, 2).Style.IsTextVertical = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.NumberFormat"
            ws.Cells(row, 2).Value = 1234
            ws.Cells(row, 2).Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]"
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Rotation"
            ws.Cells(row, 2).Value = "35 degrees up"
            ws.Cells(row, 2).Style.Rotation = 35
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.ShrinkToFit"
            ws.Cells(row, 2).Value = "This property is set to true so this text appears shrunk."
            ws.Cells(row, 2).Style.ShrinkToFit = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.VerticalAlignment ="
            ws.Cells(row, 2).Value = "VerticalAlignmentStyle.Top"
            <font color="Green">' Set row height to 30 points.</font>
            ws.Rows(row).Height = 30 * 20
            ws.Cells(row, 2).Style.VerticalAlignment = VerticalAlignmentStyle.Top
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.WrapText"
            ws.Cells(row, 2).Value = "This property is set to true so this text appears broken into multiple lines."
            ws.Cells(row, 2).Style.WrapText = True
            End Sub
            </code>
            <code lang="C#">
            static void StylesSample(ExcelWorksheet ws)
            {
            ws.Cells[0,0].Value = "Cell style examples:";
            
            int row = 0;
            
            <font color="Green">// Column width of 4, 30 and 35 characters.</font>
            ws.Columns[0].Width = 4 * 256;
            ws.Columns[1].Width = 30 * 256;
            ws.Columns[2].Width = 35 * 256;
            
            ws.Cells[row+=2,1].Value = ".Style.Borders.SetBorders(...)";
            ws.Cells[row,2].Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin);
            
            ws.Cells[row+=2,1].Value = ".Style.FillPattern.SetPattern(...)";
            ws.Cells[row,2].Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow);
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Color =";
            ws.Cells[row,2].Value = "Color.Blue";
            ws.Cells[row,2].Style.Font.Color = Color.Blue;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Italic =";
            ws.Cells[row,2].Value = "true";
            ws.Cells[row,2].Style.Font.Italic = true;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Name =";
            ws.Cells[row,2].Value = "Comic Sans MS";
            ws.Cells[row,2].Style.Font.Name = "Comic Sans MS";
            
            ws.Cells[row+=2,1].Value = ".Style.Font.ScriptPosition =";
            ws.Cells[row,2].Value = "ScriptPosition.Superscript";
            ws.Cells[row,2].Style.Font.ScriptPosition = ScriptPosition.Superscript;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Size =";
            ws.Cells[row,2].Value = "18 * 20";
            ws.Cells[row,2].Style.Font.Size = 18 * 20;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Strikeout =";
            ws.Cells[row,2].Value = "true";
            ws.Cells[row,2].Style.Font.Strikeout = true;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.UnderlineStyle =";
            ws.Cells[row,2].Value = "UnderlineStyle.Double";
            ws.Cells[row,2].Style.Font.UnderlineStyle = UnderlineStyle.Double;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Weight =";
            ws.Cells[row,2].Value = "ExcelFont.BoldWeight";
            ws.Cells[row,2].Style.Font.Weight = ExcelFont.BoldWeight;
            
            ws.Cells[row+=2,1].Value = ".Style.HorizontalAlignment =";
            ws.Cells[row,2].Value = "HorizontalAlignmentStyle.Center";
            ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Center;
            
            ws.Cells[row+=2,1].Value = ".Style.Indent";
            ws.Cells[row,2].Value = "five";
            ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Left;
            ws.Cells[row,2].Style.Indent = 5;
            
            ws.Cells[row+=2,1].Value = ".Style.IsTextVertical = ";
            ws.Cells[row,2].Value = "true";
            <font color="Green">// Set row height to 50 points.</font>
            ws.Rows[row].Height = 50 * 20;
            ws.Cells[row,2].Style.IsTextVertical = true;
            
            ws.Cells[row+=2,1].Value = ".Style.NumberFormat";
            ws.Cells[row,2].Value = 1234;
            ws.Cells[row,2].Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]";
            
            ws.Cells[row+=2,1].Value = ".Style.Rotation";
            ws.Cells[row,2].Value = "35 degrees up";
            ws.Cells[row,2].Style.Rotation = 35;
            
            ws.Cells[row+=2,1].Value = ".Style.ShrinkToFit";
            ws.Cells[row,2].Value = "This property is set to true so this text appears shrunk.";
            ws.Cells[row,2].Style.ShrinkToFit = true;
            
            ws.Cells[row+=2,1].Value = ".Style.VerticalAlignment =";
            ws.Cells[row,2].Value = "VerticalAlignmentStyle.Top";
            <font color="Green">// Set row height to 30 points.</font>
            ws.Rows[row].Height = 30 * 20;
            ws.Cells[row,2].Style.VerticalAlignment = VerticalAlignmentStyle.Top;
            
            ws.Cells[row+=2,1].Value = ".Style.WrapText";
            ws.Cells[row,2].Value = "This property is set to true so this text appears broken into multiple lines.";
            ws.Cells[row,2].Style.WrapText = true;
            }
            </code>
            </example>
            <seealso cref="P:MB.WinEIDrive.Excel.CellStyle.VerticalAlignment"/>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellStyle.Indent">
            <summary>
            Gets or sets cell data indentation.
            </summary>
            <remarks>
            <p>Indents cell contents from any edge of the cell, depending on
            <see cref="P:MB.WinEIDrive.Excel.CellStyle.IsTextVertical">IsTextVertical</see> and associated alignment. If
            you set this property to non-zero value and <see cref="P:MB.WinEIDrive.Excel.CellStyle.IsTextVertical">
            IsTextVertical</see> is <b>false</b>, it is recommended thay you also set
            <see cref="P:MB.WinEIDrive.Excel.CellStyle.HorizontalAlignment">HorizontalAlignment</see> to
            <see cref="F:MB.WinEIDrive.Excel.HorizontalAlignmentStyle.Left">HorizontalAlignmentStyle.Left</see> or
            <see cref="F:MB.WinEIDrive.Excel.HorizontalAlignmentStyle.Right">HorizontalAlignmentStyle.Right</see>.
            Otherwise some versions of Microsoft Excel will have problems interpreting Indent value in
            "Format Cells..." dialog &gt; "Alignment" tab. In the case where
            <see cref="P:MB.WinEIDrive.Excel.CellStyle.IsTextVertical">IsTextVertical</see> is <b>true</b>, you should set
            <see cref="P:MB.WinEIDrive.Excel.CellStyle.VerticalAlignment">VerticalAlignment</see> instead.</p>
            <p>Unit is one character. Value must be between 0 and 15.</p>
            <p>Default value for this property is 0.</p>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if value is out of range.</exception>
            <example> Following code demonstrates various cell style properties:
            <code lang="Visual Basic">
            Sub StylesSample(ByVal ws As ExcelWorksheet)
            ws.Cells(0, 0).Value = "Cell style examples:"
            
            Dim row As Integer = 0
            
            <font color="Green">' Column width of 4, 30 and 35 characters.</font>
            ws.Columns(0).Width = 4 * 256
            ws.Columns(1).Width = 30 * 256
            ws.Columns(2).Width = 35 * 256
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Borders.SetBorders(...)"
            ws.Cells(row, 2).Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin)
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.FillPattern.SetPattern(...)"
            ws.Cells(row, 2).Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow)
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Color ="
            ws.Cells(row, 2).Value = "Color.Blue"
            ws.Cells(row, 2).Style.Font.Color = Color.Blue
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Italic ="
            ws.Cells(row, 2).Value = "true"
            ws.Cells(row, 2).Style.Font.Italic = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Name ="
            ws.Cells(row, 2).Value = "Comic Sans MS"
            ws.Cells(row, 2).Style.Font.Name = "Comic Sans MS"
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.ScriptPosition ="
            ws.Cells(row, 2).Value = "ScriptPosition.Superscript"
            ws.Cells(row, 2).Style.Font.ScriptPosition = ScriptPosition.Superscript
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Size ="
            ws.Cells(row, 2).Value = "18 * 20"
            ws.Cells(row, 2).Style.Font.Size = 18 * 20
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Strikeout ="
            ws.Cells(row, 2).Value = "true"
            ws.Cells(row, 2).Style.Font.Strikeout = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.UnderlineStyle ="
            ws.Cells(row, 2).Value = "UnderlineStyle.Double"
            ws.Cells(row, 2).Style.Font.UnderlineStyle = UnderlineStyle.Double
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Weight ="
            ws.Cells(row, 2).Value = "ExcelFont.BoldWeight"
            ws.Cells(row, 2).Style.Font.Weight = ExcelFont.BoldWeight
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.HorizontalAlignment ="
            ws.Cells(row, 2).Value = "HorizontalAlignmentStyle.Center"
            ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Center
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Indent"
            ws.Cells(row, 2).Value = "five"
            ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Left
            ws.Cells(row, 2).Style.Indent = 5
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.IsTextVertical = "
            ws.Cells(row, 2).Value = "true"
            <font color="Green">' Set row height to 50 points.</font>
            ws.Rows(row).Height = 50 * 20
            ws.Cells(row, 2).Style.IsTextVertical = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.NumberFormat"
            ws.Cells(row, 2).Value = 1234
            ws.Cells(row, 2).Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]"
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Rotation"
            ws.Cells(row, 2).Value = "35 degrees up"
            ws.Cells(row, 2).Style.Rotation = 35
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.ShrinkToFit"
            ws.Cells(row, 2).Value = "This property is set to true so this text appears shrunk."
            ws.Cells(row, 2).Style.ShrinkToFit = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.VerticalAlignment ="
            ws.Cells(row, 2).Value = "VerticalAlignmentStyle.Top"
            <font color="Green">' Set row height to 30 points.</font>
            ws.Rows(row).Height = 30 * 20
            ws.Cells(row, 2).Style.VerticalAlignment = VerticalAlignmentStyle.Top
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.WrapText"
            ws.Cells(row, 2).Value = "This property is set to true so this text appears broken into multiple lines."
            ws.Cells(row, 2).Style.WrapText = True
            End Sub
            </code>
            <code lang="C#">
            static void StylesSample(ExcelWorksheet ws)
            {
            ws.Cells[0,0].Value = "Cell style examples:";
            
            int row = 0;
            
            <font color="Green">// Column width of 4, 30 and 35 characters.</font>
            ws.Columns[0].Width = 4 * 256;
            ws.Columns[1].Width = 30 * 256;
            ws.Columns[2].Width = 35 * 256;
            
            ws.Cells[row+=2,1].Value = ".Style.Borders.SetBorders(...)";
            ws.Cells[row,2].Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin);
            
            ws.Cells[row+=2,1].Value = ".Style.FillPattern.SetPattern(...)";
            ws.Cells[row,2].Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow);
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Color =";
            ws.Cells[row,2].Value = "Color.Blue";
            ws.Cells[row,2].Style.Font.Color = Color.Blue;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Italic =";
            ws.Cells[row,2].Value = "true";
            ws.Cells[row,2].Style.Font.Italic = true;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Name =";
            ws.Cells[row,2].Value = "Comic Sans MS";
            ws.Cells[row,2].Style.Font.Name = "Comic Sans MS";
            
            ws.Cells[row+=2,1].Value = ".Style.Font.ScriptPosition =";
            ws.Cells[row,2].Value = "ScriptPosition.Superscript";
            ws.Cells[row,2].Style.Font.ScriptPosition = ScriptPosition.Superscript;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Size =";
            ws.Cells[row,2].Value = "18 * 20";
            ws.Cells[row,2].Style.Font.Size = 18 * 20;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Strikeout =";
            ws.Cells[row,2].Value = "true";
            ws.Cells[row,2].Style.Font.Strikeout = true;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.UnderlineStyle =";
            ws.Cells[row,2].Value = "UnderlineStyle.Double";
            ws.Cells[row,2].Style.Font.UnderlineStyle = UnderlineStyle.Double;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Weight =";
            ws.Cells[row,2].Value = "ExcelFont.BoldWeight";
            ws.Cells[row,2].Style.Font.Weight = ExcelFont.BoldWeight;
            
            ws.Cells[row+=2,1].Value = ".Style.HorizontalAlignment =";
            ws.Cells[row,2].Value = "HorizontalAlignmentStyle.Center";
            ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Center;
            
            ws.Cells[row+=2,1].Value = ".Style.Indent";
            ws.Cells[row,2].Value = "five";
            ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Left;
            ws.Cells[row,2].Style.Indent = 5;
            
            ws.Cells[row+=2,1].Value = ".Style.IsTextVertical = ";
            ws.Cells[row,2].Value = "true";
            <font color="Green">// Set row height to 50 points.</font>
            ws.Rows[row].Height = 50 * 20;
            ws.Cells[row,2].Style.IsTextVertical = true;
            
            ws.Cells[row+=2,1].Value = ".Style.NumberFormat";
            ws.Cells[row,2].Value = 1234;
            ws.Cells[row,2].Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]";
            
            ws.Cells[row+=2,1].Value = ".Style.Rotation";
            ws.Cells[row,2].Value = "35 degrees up";
            ws.Cells[row,2].Style.Rotation = 35;
            
            ws.Cells[row+=2,1].Value = ".Style.ShrinkToFit";
            ws.Cells[row,2].Value = "This property is set to true so this text appears shrunk.";
            ws.Cells[row,2].Style.ShrinkToFit = true;
            
            ws.Cells[row+=2,1].Value = ".Style.VerticalAlignment =";
            ws.Cells[row,2].Value = "VerticalAlignmentStyle.Top";
            <font color="Green">// Set row height to 30 points.</font>
            ws.Rows[row].Height = 30 * 20;
            ws.Cells[row,2].Style.VerticalAlignment = VerticalAlignmentStyle.Top;
            
            ws.Cells[row+=2,1].Value = ".Style.WrapText";
            ws.Cells[row,2].Value = "This property is set to true so this text appears broken into multiple lines.";
            ws.Cells[row,2].Style.WrapText = true;
            }
            </code>
            </example>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellStyle.IsDefault">
            <summary>
            Returns <b>true</b> if cell style is default; otherwise, <b>false</b>.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellStyle.IsTextVertical">
            <summary>
            Gets or sets whether the cell text is displayed in a vertical style.
            </summary>
            <remarks>
            <p>If <b>true</b> letters are stacked top-to-bottom.</p>
            <p>Because of Microsoft Excel limitations, this property
            and <see cref="P:MB.WinEIDrive.Excel.CellStyle.Rotation">Rotation</see> property can't be used at the same time.
            When set, <see cref="P:MB.WinEIDrive.Excel.CellStyle.Rotation">Rotation</see> property is set to 0.
            If <see cref="P:MB.WinEIDrive.Excel.CellStyle.Rotation">Rotation</see> property is latter set to some non-zero value,
            this property will be set to <b>false</b>.</p>
            <p>Default value for this property is <b>false</b>.</p>
            </remarks>
            <example> Following code demonstrates various cell style properties:
            <code lang="Visual Basic">
            Sub StylesSample(ByVal ws As ExcelWorksheet)
            ws.Cells(0, 0).Value = "Cell style examples:"
            
            Dim row As Integer = 0
            
            <font color="Green">' Column width of 4, 30 and 35 characters.</font>
            ws.Columns(0).Width = 4 * 256
            ws.Columns(1).Width = 30 * 256
            ws.Columns(2).Width = 35 * 256
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Borders.SetBorders(...)"
            ws.Cells(row, 2).Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin)
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.FillPattern.SetPattern(...)"
            ws.Cells(row, 2).Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow)
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Color ="
            ws.Cells(row, 2).Value = "Color.Blue"
            ws.Cells(row, 2).Style.Font.Color = Color.Blue
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Italic ="
            ws.Cells(row, 2).Value = "true"
            ws.Cells(row, 2).Style.Font.Italic = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Name ="
            ws.Cells(row, 2).Value = "Comic Sans MS"
            ws.Cells(row, 2).Style.Font.Name = "Comic Sans MS"
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.ScriptPosition ="
            ws.Cells(row, 2).Value = "ScriptPosition.Superscript"
            ws.Cells(row, 2).Style.Font.ScriptPosition = ScriptPosition.Superscript
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Size ="
            ws.Cells(row, 2).Value = "18 * 20"
            ws.Cells(row, 2).Style.Font.Size = 18 * 20
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Strikeout ="
            ws.Cells(row, 2).Value = "true"
            ws.Cells(row, 2).Style.Font.Strikeout = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.UnderlineStyle ="
            ws.Cells(row, 2).Value = "UnderlineStyle.Double"
            ws.Cells(row, 2).Style.Font.UnderlineStyle = UnderlineStyle.Double
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Weight ="
            ws.Cells(row, 2).Value = "ExcelFont.BoldWeight"
            ws.Cells(row, 2).Style.Font.Weight = ExcelFont.BoldWeight
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.HorizontalAlignment ="
            ws.Cells(row, 2).Value = "HorizontalAlignmentStyle.Center"
            ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Center
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Indent"
            ws.Cells(row, 2).Value = "five"
            ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Left
            ws.Cells(row, 2).Style.Indent = 5
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.IsTextVertical = "
            ws.Cells(row, 2).Value = "true"
            <font color="Green">' Set row height to 50 points.</font>
            ws.Rows(row).Height = 50 * 20
            ws.Cells(row, 2).Style.IsTextVertical = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.NumberFormat"
            ws.Cells(row, 2).Value = 1234
            ws.Cells(row, 2).Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]"
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Rotation"
            ws.Cells(row, 2).Value = "35 degrees up"
            ws.Cells(row, 2).Style.Rotation = 35
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.ShrinkToFit"
            ws.Cells(row, 2).Value = "This property is set to true so this text appears shrunk."
            ws.Cells(row, 2).Style.ShrinkToFit = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.VerticalAlignment ="
            ws.Cells(row, 2).Value = "VerticalAlignmentStyle.Top"
            <font color="Green">' Set row height to 30 points.</font>
            ws.Rows(row).Height = 30 * 20
            ws.Cells(row, 2).Style.VerticalAlignment = VerticalAlignmentStyle.Top
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.WrapText"
            ws.Cells(row, 2).Value = "This property is set to true so this text appears broken into multiple lines."
            ws.Cells(row, 2).Style.WrapText = True
            End Sub
            </code>
            <code lang="C#">
            static void StylesSample(ExcelWorksheet ws)
            {
            ws.Cells[0,0].Value = "Cell style examples:";
            
            int row = 0;
            
            <font color="Green">// Column width of 4, 30 and 35 characters.</font>
            ws.Columns[0].Width = 4 * 256;
            ws.Columns[1].Width = 30 * 256;
            ws.Columns[2].Width = 35 * 256;
            
            ws.Cells[row+=2,1].Value = ".Style.Borders.SetBorders(...)";
            ws.Cells[row,2].Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin);
            
            ws.Cells[row+=2,1].Value = ".Style.FillPattern.SetPattern(...)";
            ws.Cells[row,2].Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow);
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Color =";
            ws.Cells[row,2].Value = "Color.Blue";
            ws.Cells[row,2].Style.Font.Color = Color.Blue;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Italic =";
            ws.Cells[row,2].Value = "true";
            ws.Cells[row,2].Style.Font.Italic = true;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Name =";
            ws.Cells[row,2].Value = "Comic Sans MS";
            ws.Cells[row,2].Style.Font.Name = "Comic Sans MS";
            
            ws.Cells[row+=2,1].Value = ".Style.Font.ScriptPosition =";
            ws.Cells[row,2].Value = "ScriptPosition.Superscript";
            ws.Cells[row,2].Style.Font.ScriptPosition = ScriptPosition.Superscript;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Size =";
            ws.Cells[row,2].Value = "18 * 20";
            ws.Cells[row,2].Style.Font.Size = 18 * 20;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Strikeout =";
            ws.Cells[row,2].Value = "true";
            ws.Cells[row,2].Style.Font.Strikeout = true;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.UnderlineStyle =";
            ws.Cells[row,2].Value = "UnderlineStyle.Double";
            ws.Cells[row,2].Style.Font.UnderlineStyle = UnderlineStyle.Double;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Weight =";
            ws.Cells[row,2].Value = "ExcelFont.BoldWeight";
            ws.Cells[row,2].Style.Font.Weight = ExcelFont.BoldWeight;
            
            ws.Cells[row+=2,1].Value = ".Style.HorizontalAlignment =";
            ws.Cells[row,2].Value = "HorizontalAlignmentStyle.Center";
            ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Center;
            
            ws.Cells[row+=2,1].Value = ".Style.Indent";
            ws.Cells[row,2].Value = "five";
            ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Left;
            ws.Cells[row,2].Style.Indent = 5;
            
            ws.Cells[row+=2,1].Value = ".Style.IsTextVertical = ";
            ws.Cells[row,2].Value = "true";
            <font color="Green">// Set row height to 50 points.</font>
            ws.Rows[row].Height = 50 * 20;
            ws.Cells[row,2].Style.IsTextVertical = true;
            
            ws.Cells[row+=2,1].Value = ".Style.NumberFormat";
            ws.Cells[row,2].Value = 1234;
            ws.Cells[row,2].Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]";
            
            ws.Cells[row+=2,1].Value = ".Style.Rotation";
            ws.Cells[row,2].Value = "35 degrees up";
            ws.Cells[row,2].Style.Rotation = 35;
            
            ws.Cells[row+=2,1].Value = ".Style.ShrinkToFit";
            ws.Cells[row,2].Value = "This property is set to true so this text appears shrunk.";
            ws.Cells[row,2].Style.ShrinkToFit = true;
            
            ws.Cells[row+=2,1].Value = ".Style.VerticalAlignment =";
            ws.Cells[row,2].Value = "VerticalAlignmentStyle.Top";
            <font color="Green">// Set row height to 30 points.</font>
            ws.Rows[row].Height = 30 * 20;
            ws.Cells[row,2].Style.VerticalAlignment = VerticalAlignmentStyle.Top;
            
            ws.Cells[row+=2,1].Value = ".Style.WrapText";
            ws.Cells[row,2].Value = "This property is set to true so this text appears broken into multiple lines.";
            ws.Cells[row,2].Style.WrapText = true;
            }
            </code>
            </example>
            <seealso cref="P:MB.WinEIDrive.Excel.CellStyle.Rotation"/>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellStyle.Locked">
            <summary>
            Gets or sets if the cell is locked.
            </summary>
            <remarks>
            <p>This property has meaning only if <see cref="P:MB.WinEIDrive.Excel.ExcelFile.Protected">ExcelFile.Protected</see>
            is set to <b>true</b>. For more information consult Microsoft Excel documentation.</p>
            <p>Default value for this property is <b>true</b>.</p>
            </remarks>
            <seealso cref="P:MB.WinEIDrive.Excel.ExcelFile.Protected">ExcelFile.Protected</seealso>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellStyle.NumberFormat">
            <summary>
            Gets or sets format string that will be used to interpret and display cell value.
            </summary>
            <remarks>
            <p>If the value of this property is <see cref="F:System.String.Empty">String.Empty</see> and
            <see cref="P:MB.WinEIDrive.Excel.ExcelCell.Value">ExcelCell.Value</see> is of
            <see cref="T:System.DateTime">DateTime</see> type,
            ISO date/time format will be used as number format.</p>
            <p>For more information on number format strings consult Microsoft Excel documentation.</p>
            Default value for this property is <see cref="F:System.String.Empty">String.Empty</see>.
            </remarks>
            <example> Following code demonstrates various cell style properties:
            <code lang="Visual Basic">
            Sub StylesSample(ByVal ws As ExcelWorksheet)
            ws.Cells(0, 0).Value = "Cell style examples:"
            
            Dim row As Integer = 0
            
            <font color="Green">' Column width of 4, 30 and 35 characters.</font>
            ws.Columns(0).Width = 4 * 256
            ws.Columns(1).Width = 30 * 256
            ws.Columns(2).Width = 35 * 256
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Borders.SetBorders(...)"
            ws.Cells(row, 2).Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin)
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.FillPattern.SetPattern(...)"
            ws.Cells(row, 2).Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow)
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Color ="
            ws.Cells(row, 2).Value = "Color.Blue"
            ws.Cells(row, 2).Style.Font.Color = Color.Blue
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Italic ="
            ws.Cells(row, 2).Value = "true"
            ws.Cells(row, 2).Style.Font.Italic = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Name ="
            ws.Cells(row, 2).Value = "Comic Sans MS"
            ws.Cells(row, 2).Style.Font.Name = "Comic Sans MS"
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.ScriptPosition ="
            ws.Cells(row, 2).Value = "ScriptPosition.Superscript"
            ws.Cells(row, 2).Style.Font.ScriptPosition = ScriptPosition.Superscript
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Size ="
            ws.Cells(row, 2).Value = "18 * 20"
            ws.Cells(row, 2).Style.Font.Size = 18 * 20
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Strikeout ="
            ws.Cells(row, 2).Value = "true"
            ws.Cells(row, 2).Style.Font.Strikeout = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.UnderlineStyle ="
            ws.Cells(row, 2).Value = "UnderlineStyle.Double"
            ws.Cells(row, 2).Style.Font.UnderlineStyle = UnderlineStyle.Double
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Weight ="
            ws.Cells(row, 2).Value = "ExcelFont.BoldWeight"
            ws.Cells(row, 2).Style.Font.Weight = ExcelFont.BoldWeight
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.HorizontalAlignment ="
            ws.Cells(row, 2).Value = "HorizontalAlignmentStyle.Center"
            ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Center
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Indent"
            ws.Cells(row, 2).Value = "five"
            ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Left
            ws.Cells(row, 2).Style.Indent = 5
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.IsTextVertical = "
            ws.Cells(row, 2).Value = "true"
            <font color="Green">' Set row height to 50 points.</font>
            ws.Rows(row).Height = 50 * 20
            ws.Cells(row, 2).Style.IsTextVertical = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.NumberFormat"
            ws.Cells(row, 2).Value = 1234
            ws.Cells(row, 2).Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]"
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Rotation"
            ws.Cells(row, 2).Value = "35 degrees up"
            ws.Cells(row, 2).Style.Rotation = 35
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.ShrinkToFit"
            ws.Cells(row, 2).Value = "This property is set to true so this text appears shrunk."
            ws.Cells(row, 2).Style.ShrinkToFit = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.VerticalAlignment ="
            ws.Cells(row, 2).Value = "VerticalAlignmentStyle.Top"
            <font color="Green">' Set row height to 30 points.</font>
            ws.Rows(row).Height = 30 * 20
            ws.Cells(row, 2).Style.VerticalAlignment = VerticalAlignmentStyle.Top
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.WrapText"
            ws.Cells(row, 2).Value = "This property is set to true so this text appears broken into multiple lines."
            ws.Cells(row, 2).Style.WrapText = True
            End Sub
            </code>
            <code lang="C#">
            static void StylesSample(ExcelWorksheet ws)
            {
            ws.Cells[0,0].Value = "Cell style examples:";
            
            int row = 0;
            
            <font color="Green">// Column width of 4, 30 and 35 characters.</font>
            ws.Columns[0].Width = 4 * 256;
            ws.Columns[1].Width = 30 * 256;
            ws.Columns[2].Width = 35 * 256;
            
            ws.Cells[row+=2,1].Value = ".Style.Borders.SetBorders(...)";
            ws.Cells[row,2].Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin);
            
            ws.Cells[row+=2,1].Value = ".Style.FillPattern.SetPattern(...)";
            ws.Cells[row,2].Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow);
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Color =";
            ws.Cells[row,2].Value = "Color.Blue";
            ws.Cells[row,2].Style.Font.Color = Color.Blue;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Italic =";
            ws.Cells[row,2].Value = "true";
            ws.Cells[row,2].Style.Font.Italic = true;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Name =";
            ws.Cells[row,2].Value = "Comic Sans MS";
            ws.Cells[row,2].Style.Font.Name = "Comic Sans MS";
            
            ws.Cells[row+=2,1].Value = ".Style.Font.ScriptPosition =";
            ws.Cells[row,2].Value = "ScriptPosition.Superscript";
            ws.Cells[row,2].Style.Font.ScriptPosition = ScriptPosition.Superscript;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Size =";
            ws.Cells[row,2].Value = "18 * 20";
            ws.Cells[row,2].Style.Font.Size = 18 * 20;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Strikeout =";
            ws.Cells[row,2].Value = "true";
            ws.Cells[row,2].Style.Font.Strikeout = true;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.UnderlineStyle =";
            ws.Cells[row,2].Value = "UnderlineStyle.Double";
            ws.Cells[row,2].Style.Font.UnderlineStyle = UnderlineStyle.Double;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Weight =";
            ws.Cells[row,2].Value = "ExcelFont.BoldWeight";
            ws.Cells[row,2].Style.Font.Weight = ExcelFont.BoldWeight;
            
            ws.Cells[row+=2,1].Value = ".Style.HorizontalAlignment =";
            ws.Cells[row,2].Value = "HorizontalAlignmentStyle.Center";
            ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Center;
            
            ws.Cells[row+=2,1].Value = ".Style.Indent";
            ws.Cells[row,2].Value = "five";
            ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Left;
            ws.Cells[row,2].Style.Indent = 5;
            
            ws.Cells[row+=2,1].Value = ".Style.IsTextVertical = ";
            ws.Cells[row,2].Value = "true";
            <font color="Green">// Set row height to 50 points.</font>
            ws.Rows[row].Height = 50 * 20;
            ws.Cells[row,2].Style.IsTextVertical = true;
            
            ws.Cells[row+=2,1].Value = ".Style.NumberFormat";
            ws.Cells[row,2].Value = 1234;
            ws.Cells[row,2].Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]";
            
            ws.Cells[row+=2,1].Value = ".Style.Rotation";
            ws.Cells[row,2].Value = "35 degrees up";
            ws.Cells[row,2].Style.Rotation = 35;
            
            ws.Cells[row+=2,1].Value = ".Style.ShrinkToFit";
            ws.Cells[row,2].Value = "This property is set to true so this text appears shrunk.";
            ws.Cells[row,2].Style.ShrinkToFit = true;
            
            ws.Cells[row+=2,1].Value = ".Style.VerticalAlignment =";
            ws.Cells[row,2].Value = "VerticalAlignmentStyle.Top";
            <font color="Green">// Set row height to 30 points.</font>
            ws.Rows[row].Height = 30 * 20;
            ws.Cells[row,2].Style.VerticalAlignment = VerticalAlignmentStyle.Top;
            
            ws.Cells[row+=2,1].Value = ".Style.WrapText";
            ws.Cells[row,2].Value = "This property is set to true so this text appears broken into multiple lines.";
            ws.Cells[row,2].Style.WrapText = true;
            }
            </code>
            </example>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellStyle.Rotation">
            <summary>
            Gets or sets cell data rotation.
            </summary>
            <remarks>
            <p>Unit is degrees (1/360th of a full circle). Value must be between -90 and 90 and specifies
            anticlockwise (counterclockwise [N.Amer]) rotation from the normal position.</p>
            <p>Because of Microsoft Excel limitations, this property and
            <see cref="P:MB.WinEIDrive.Excel.CellStyle.IsTextVertical">IsTextVertical</see> property can't be used at the
            same time. If <see cref="P:MB.WinEIDrive.Excel.CellStyle.IsTextVertical">IsTextVertical</see> is <b>true</b> and
            rotation is set, <see cref="P:MB.WinEIDrive.Excel.CellStyle.IsTextVertical">IsTextVertical</see> will be set to
            <b>false</b>. When <see cref="P:MB.WinEIDrive.Excel.CellStyle.IsTextVertical">IsTextVertical</see> is set to
            <b>true</b>, rotation will be set to 0.</p>
            <p>Default value for this property is 0.</p>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if value is not between -90 and 90.</exception>
            <example> Following code demonstrates various cell style properties:
            <code lang="Visual Basic">
            Sub StylesSample(ByVal ws As ExcelWorksheet)
            ws.Cells(0, 0).Value = "Cell style examples:"
            
            Dim row As Integer = 0
            
            <font color="Green">' Column width of 4, 30 and 35 characters.</font>
            ws.Columns(0).Width = 4 * 256
            ws.Columns(1).Width = 30 * 256
            ws.Columns(2).Width = 35 * 256
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Borders.SetBorders(...)"
            ws.Cells(row, 2).Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin)
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.FillPattern.SetPattern(...)"
            ws.Cells(row, 2).Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow)
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Color ="
            ws.Cells(row, 2).Value = "Color.Blue"
            ws.Cells(row, 2).Style.Font.Color = Color.Blue
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Italic ="
            ws.Cells(row, 2).Value = "true"
            ws.Cells(row, 2).Style.Font.Italic = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Name ="
            ws.Cells(row, 2).Value = "Comic Sans MS"
            ws.Cells(row, 2).Style.Font.Name = "Comic Sans MS"
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.ScriptPosition ="
            ws.Cells(row, 2).Value = "ScriptPosition.Superscript"
            ws.Cells(row, 2).Style.Font.ScriptPosition = ScriptPosition.Superscript
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Size ="
            ws.Cells(row, 2).Value = "18 * 20"
            ws.Cells(row, 2).Style.Font.Size = 18 * 20
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Strikeout ="
            ws.Cells(row, 2).Value = "true"
            ws.Cells(row, 2).Style.Font.Strikeout = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.UnderlineStyle ="
            ws.Cells(row, 2).Value = "UnderlineStyle.Double"
            ws.Cells(row, 2).Style.Font.UnderlineStyle = UnderlineStyle.Double
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Weight ="
            ws.Cells(row, 2).Value = "ExcelFont.BoldWeight"
            ws.Cells(row, 2).Style.Font.Weight = ExcelFont.BoldWeight
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.HorizontalAlignment ="
            ws.Cells(row, 2).Value = "HorizontalAlignmentStyle.Center"
            ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Center
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Indent"
            ws.Cells(row, 2).Value = "five"
            ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Left
            ws.Cells(row, 2).Style.Indent = 5
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.IsTextVertical = "
            ws.Cells(row, 2).Value = "true"
            <font color="Green">' Set row height to 50 points.</font>
            ws.Rows(row).Height = 50 * 20
            ws.Cells(row, 2).Style.IsTextVertical = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.NumberFormat"
            ws.Cells(row, 2).Value = 1234
            ws.Cells(row, 2).Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]"
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Rotation"
            ws.Cells(row, 2).Value = "35 degrees up"
            ws.Cells(row, 2).Style.Rotation = 35
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.ShrinkToFit"
            ws.Cells(row, 2).Value = "This property is set to true so this text appears shrunk."
            ws.Cells(row, 2).Style.ShrinkToFit = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.VerticalAlignment ="
            ws.Cells(row, 2).Value = "VerticalAlignmentStyle.Top"
            <font color="Green">' Set row height to 30 points.</font>
            ws.Rows(row).Height = 30 * 20
            ws.Cells(row, 2).Style.VerticalAlignment = VerticalAlignmentStyle.Top
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.WrapText"
            ws.Cells(row, 2).Value = "This property is set to true so this text appears broken into multiple lines."
            ws.Cells(row, 2).Style.WrapText = True
            End Sub
            </code>
            <code lang="C#">
            static void StylesSample(ExcelWorksheet ws)
            {
            ws.Cells[0,0].Value = "Cell style examples:";
            
            int row = 0;
            
            <font color="Green">// Column width of 4, 30 and 35 characters.</font>
            ws.Columns[0].Width = 4 * 256;
            ws.Columns[1].Width = 30 * 256;
            ws.Columns[2].Width = 35 * 256;
            
            ws.Cells[row+=2,1].Value = ".Style.Borders.SetBorders(...)";
            ws.Cells[row,2].Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin);
            
            ws.Cells[row+=2,1].Value = ".Style.FillPattern.SetPattern(...)";
            ws.Cells[row,2].Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow);
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Color =";
            ws.Cells[row,2].Value = "Color.Blue";
            ws.Cells[row,2].Style.Font.Color = Color.Blue;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Italic =";
            ws.Cells[row,2].Value = "true";
            ws.Cells[row,2].Style.Font.Italic = true;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Name =";
            ws.Cells[row,2].Value = "Comic Sans MS";
            ws.Cells[row,2].Style.Font.Name = "Comic Sans MS";
            
            ws.Cells[row+=2,1].Value = ".Style.Font.ScriptPosition =";
            ws.Cells[row,2].Value = "ScriptPosition.Superscript";
            ws.Cells[row,2].Style.Font.ScriptPosition = ScriptPosition.Superscript;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Size =";
            ws.Cells[row,2].Value = "18 * 20";
            ws.Cells[row,2].Style.Font.Size = 18 * 20;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Strikeout =";
            ws.Cells[row,2].Value = "true";
            ws.Cells[row,2].Style.Font.Strikeout = true;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.UnderlineStyle =";
            ws.Cells[row,2].Value = "UnderlineStyle.Double";
            ws.Cells[row,2].Style.Font.UnderlineStyle = UnderlineStyle.Double;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Weight =";
            ws.Cells[row,2].Value = "ExcelFont.BoldWeight";
            ws.Cells[row,2].Style.Font.Weight = ExcelFont.BoldWeight;
            
            ws.Cells[row+=2,1].Value = ".Style.HorizontalAlignment =";
            ws.Cells[row,2].Value = "HorizontalAlignmentStyle.Center";
            ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Center;
            
            ws.Cells[row+=2,1].Value = ".Style.Indent";
            ws.Cells[row,2].Value = "five";
            ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Left;
            ws.Cells[row,2].Style.Indent = 5;
            
            ws.Cells[row+=2,1].Value = ".Style.IsTextVertical = ";
            ws.Cells[row,2].Value = "true";
            <font color="Green">// Set row height to 50 points.</font>
            ws.Rows[row].Height = 50 * 20;
            ws.Cells[row,2].Style.IsTextVertical = true;
            
            ws.Cells[row+=2,1].Value = ".Style.NumberFormat";
            ws.Cells[row,2].Value = 1234;
            ws.Cells[row,2].Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]";
            
            ws.Cells[row+=2,1].Value = ".Style.Rotation";
            ws.Cells[row,2].Value = "35 degrees up";
            ws.Cells[row,2].Style.Rotation = 35;
            
            ws.Cells[row+=2,1].Value = ".Style.ShrinkToFit";
            ws.Cells[row,2].Value = "This property is set to true so this text appears shrunk.";
            ws.Cells[row,2].Style.ShrinkToFit = true;
            
            ws.Cells[row+=2,1].Value = ".Style.VerticalAlignment =";
            ws.Cells[row,2].Value = "VerticalAlignmentStyle.Top";
            <font color="Green">// Set row height to 30 points.</font>
            ws.Rows[row].Height = 30 * 20;
            ws.Cells[row,2].Style.VerticalAlignment = VerticalAlignmentStyle.Top;
            
            ws.Cells[row+=2,1].Value = ".Style.WrapText";
            ws.Cells[row,2].Value = "This property is set to true so this text appears broken into multiple lines.";
            ws.Cells[row,2].Style.WrapText = true;
            }
            </code>
            </example>
            <seealso cref="P:MB.WinEIDrive.Excel.CellStyle.IsTextVertical"/>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellStyle.ShrinkToFit">
            <summary>
            Gets or sets if the cell text is shrunk to fit the cell.
            </summary>
            <remarks>
            <p>If set to <b>true</b>, reduces the apparent size of font characters so that all data in a selected
            cell fits within the column. For more information consult Microsoft Excel documentation.</p>
            Default value for this property is <b>false</b>.
            </remarks>
            <example> Following code demonstrates various cell style properties:
            <code lang="Visual Basic">
            Sub StylesSample(ByVal ws As ExcelWorksheet)
            ws.Cells(0, 0).Value = "Cell style examples:"
            
            Dim row As Integer = 0
            
            <font color="Green">' Column width of 4, 30 and 35 characters.</font>
            ws.Columns(0).Width = 4 * 256
            ws.Columns(1).Width = 30 * 256
            ws.Columns(2).Width = 35 * 256
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Borders.SetBorders(...)"
            ws.Cells(row, 2).Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin)
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.FillPattern.SetPattern(...)"
            ws.Cells(row, 2).Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow)
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Color ="
            ws.Cells(row, 2).Value = "Color.Blue"
            ws.Cells(row, 2).Style.Font.Color = Color.Blue
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Italic ="
            ws.Cells(row, 2).Value = "true"
            ws.Cells(row, 2).Style.Font.Italic = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Name ="
            ws.Cells(row, 2).Value = "Comic Sans MS"
            ws.Cells(row, 2).Style.Font.Name = "Comic Sans MS"
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.ScriptPosition ="
            ws.Cells(row, 2).Value = "ScriptPosition.Superscript"
            ws.Cells(row, 2).Style.Font.ScriptPosition = ScriptPosition.Superscript
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Size ="
            ws.Cells(row, 2).Value = "18 * 20"
            ws.Cells(row, 2).Style.Font.Size = 18 * 20
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Strikeout ="
            ws.Cells(row, 2).Value = "true"
            ws.Cells(row, 2).Style.Font.Strikeout = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.UnderlineStyle ="
            ws.Cells(row, 2).Value = "UnderlineStyle.Double"
            ws.Cells(row, 2).Style.Font.UnderlineStyle = UnderlineStyle.Double
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Weight ="
            ws.Cells(row, 2).Value = "ExcelFont.BoldWeight"
            ws.Cells(row, 2).Style.Font.Weight = ExcelFont.BoldWeight
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.HorizontalAlignment ="
            ws.Cells(row, 2).Value = "HorizontalAlignmentStyle.Center"
            ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Center
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Indent"
            ws.Cells(row, 2).Value = "five"
            ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Left
            ws.Cells(row, 2).Style.Indent = 5
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.IsTextVertical = "
            ws.Cells(row, 2).Value = "true"
            <font color="Green">' Set row height to 50 points.</font>
            ws.Rows(row).Height = 50 * 20
            ws.Cells(row, 2).Style.IsTextVertical = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.NumberFormat"
            ws.Cells(row, 2).Value = 1234
            ws.Cells(row, 2).Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]"
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Rotation"
            ws.Cells(row, 2).Value = "35 degrees up"
            ws.Cells(row, 2).Style.Rotation = 35
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.ShrinkToFit"
            ws.Cells(row, 2).Value = "This property is set to true so this text appears shrunk."
            ws.Cells(row, 2).Style.ShrinkToFit = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.VerticalAlignment ="
            ws.Cells(row, 2).Value = "VerticalAlignmentStyle.Top"
            <font color="Green">' Set row height to 30 points.</font>
            ws.Rows(row).Height = 30 * 20
            ws.Cells(row, 2).Style.VerticalAlignment = VerticalAlignmentStyle.Top
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.WrapText"
            ws.Cells(row, 2).Value = "This property is set to true so this text appears broken into multiple lines."
            ws.Cells(row, 2).Style.WrapText = True
            End Sub
            </code>
            <code lang="C#">
            static void StylesSample(ExcelWorksheet ws)
            {
            ws.Cells[0,0].Value = "Cell style examples:";
            
            int row = 0;
            
            <font color="Green">// Column width of 4, 30 and 35 characters.</font>
            ws.Columns[0].Width = 4 * 256;
            ws.Columns[1].Width = 30 * 256;
            ws.Columns[2].Width = 35 * 256;
            
            ws.Cells[row+=2,1].Value = ".Style.Borders.SetBorders(...)";
            ws.Cells[row,2].Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin);
            
            ws.Cells[row+=2,1].Value = ".Style.FillPattern.SetPattern(...)";
            ws.Cells[row,2].Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow);
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Color =";
            ws.Cells[row,2].Value = "Color.Blue";
            ws.Cells[row,2].Style.Font.Color = Color.Blue;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Italic =";
            ws.Cells[row,2].Value = "true";
            ws.Cells[row,2].Style.Font.Italic = true;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Name =";
            ws.Cells[row,2].Value = "Comic Sans MS";
            ws.Cells[row,2].Style.Font.Name = "Comic Sans MS";
            
            ws.Cells[row+=2,1].Value = ".Style.Font.ScriptPosition =";
            ws.Cells[row,2].Value = "ScriptPosition.Superscript";
            ws.Cells[row,2].Style.Font.ScriptPosition = ScriptPosition.Superscript;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Size =";
            ws.Cells[row,2].Value = "18 * 20";
            ws.Cells[row,2].Style.Font.Size = 18 * 20;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Strikeout =";
            ws.Cells[row,2].Value = "true";
            ws.Cells[row,2].Style.Font.Strikeout = true;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.UnderlineStyle =";
            ws.Cells[row,2].Value = "UnderlineStyle.Double";
            ws.Cells[row,2].Style.Font.UnderlineStyle = UnderlineStyle.Double;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Weight =";
            ws.Cells[row,2].Value = "ExcelFont.BoldWeight";
            ws.Cells[row,2].Style.Font.Weight = ExcelFont.BoldWeight;
            
            ws.Cells[row+=2,1].Value = ".Style.HorizontalAlignment =";
            ws.Cells[row,2].Value = "HorizontalAlignmentStyle.Center";
            ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Center;
            
            ws.Cells[row+=2,1].Value = ".Style.Indent";
            ws.Cells[row,2].Value = "five";
            ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Left;
            ws.Cells[row,2].Style.Indent = 5;
            
            ws.Cells[row+=2,1].Value = ".Style.IsTextVertical = ";
            ws.Cells[row,2].Value = "true";
            <font color="Green">// Set row height to 50 points.</font>
            ws.Rows[row].Height = 50 * 20;
            ws.Cells[row,2].Style.IsTextVertical = true;
            
            ws.Cells[row+=2,1].Value = ".Style.NumberFormat";
            ws.Cells[row,2].Value = 1234;
            ws.Cells[row,2].Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]";
            
            ws.Cells[row+=2,1].Value = ".Style.Rotation";
            ws.Cells[row,2].Value = "35 degrees up";
            ws.Cells[row,2].Style.Rotation = 35;
            
            ws.Cells[row+=2,1].Value = ".Style.ShrinkToFit";
            ws.Cells[row,2].Value = "This property is set to true so this text appears shrunk.";
            ws.Cells[row,2].Style.ShrinkToFit = true;
            
            ws.Cells[row+=2,1].Value = ".Style.VerticalAlignment =";
            ws.Cells[row,2].Value = "VerticalAlignmentStyle.Top";
            <font color="Green">// Set row height to 30 points.</font>
            ws.Rows[row].Height = 30 * 20;
            ws.Cells[row,2].Style.VerticalAlignment = VerticalAlignmentStyle.Top;
            
            ws.Cells[row+=2,1].Value = ".Style.WrapText";
            ws.Cells[row,2].Value = "This property is set to true so this text appears broken into multiple lines.";
            ws.Cells[row,2].Style.WrapText = true;
            }
            </code>
            </example>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellStyle.VerticalAlignment">
            <summary>
            Gets or sets vertical alignment.
            </summary>
            <remarks>
            Default value for this property is <see cref="F:MB.WinEIDrive.Excel.VerticalAlignmentStyle.Bottom">
            VerticalAlignmentStyle.Bottom</see>.
            </remarks>
            <example> Following code demonstrates various cell style properties:
            <code lang="Visual Basic">
            Sub StylesSample(ByVal ws As ExcelWorksheet)
            ws.Cells(0, 0).Value = "Cell style examples:"
            
            Dim row As Integer = 0
            
            <font color="Green">' Column width of 4, 30 and 35 characters.</font>
            ws.Columns(0).Width = 4 * 256
            ws.Columns(1).Width = 30 * 256
            ws.Columns(2).Width = 35 * 256
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Borders.SetBorders(...)"
            ws.Cells(row, 2).Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin)
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.FillPattern.SetPattern(...)"
            ws.Cells(row, 2).Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow)
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Color ="
            ws.Cells(row, 2).Value = "Color.Blue"
            ws.Cells(row, 2).Style.Font.Color = Color.Blue
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Italic ="
            ws.Cells(row, 2).Value = "true"
            ws.Cells(row, 2).Style.Font.Italic = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Name ="
            ws.Cells(row, 2).Value = "Comic Sans MS"
            ws.Cells(row, 2).Style.Font.Name = "Comic Sans MS"
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.ScriptPosition ="
            ws.Cells(row, 2).Value = "ScriptPosition.Superscript"
            ws.Cells(row, 2).Style.Font.ScriptPosition = ScriptPosition.Superscript
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Size ="
            ws.Cells(row, 2).Value = "18 * 20"
            ws.Cells(row, 2).Style.Font.Size = 18 * 20
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Strikeout ="
            ws.Cells(row, 2).Value = "true"
            ws.Cells(row, 2).Style.Font.Strikeout = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.UnderlineStyle ="
            ws.Cells(row, 2).Value = "UnderlineStyle.Double"
            ws.Cells(row, 2).Style.Font.UnderlineStyle = UnderlineStyle.Double
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Weight ="
            ws.Cells(row, 2).Value = "ExcelFont.BoldWeight"
            ws.Cells(row, 2).Style.Font.Weight = ExcelFont.BoldWeight
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.HorizontalAlignment ="
            ws.Cells(row, 2).Value = "HorizontalAlignmentStyle.Center"
            ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Center
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Indent"
            ws.Cells(row, 2).Value = "five"
            ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Left
            ws.Cells(row, 2).Style.Indent = 5
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.IsTextVertical = "
            ws.Cells(row, 2).Value = "true"
            <font color="Green">' Set row height to 50 points.</font>
            ws.Rows(row).Height = 50 * 20
            ws.Cells(row, 2).Style.IsTextVertical = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.NumberFormat"
            ws.Cells(row, 2).Value = 1234
            ws.Cells(row, 2).Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]"
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Rotation"
            ws.Cells(row, 2).Value = "35 degrees up"
            ws.Cells(row, 2).Style.Rotation = 35
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.ShrinkToFit"
            ws.Cells(row, 2).Value = "This property is set to true so this text appears shrunk."
            ws.Cells(row, 2).Style.ShrinkToFit = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.VerticalAlignment ="
            ws.Cells(row, 2).Value = "VerticalAlignmentStyle.Top"
            <font color="Green">' Set row height to 30 points.</font>
            ws.Rows(row).Height = 30 * 20
            ws.Cells(row, 2).Style.VerticalAlignment = VerticalAlignmentStyle.Top
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.WrapText"
            ws.Cells(row, 2).Value = "This property is set to true so this text appears broken into multiple lines."
            ws.Cells(row, 2).Style.WrapText = True
            End Sub
            </code>
            <code lang="C#">
            static void StylesSample(ExcelWorksheet ws)
            {
            ws.Cells[0,0].Value = "Cell style examples:";
            
            int row = 0;
            
            <font color="Green">// Column width of 4, 30 and 35 characters.</font>
            ws.Columns[0].Width = 4 * 256;
            ws.Columns[1].Width = 30 * 256;
            ws.Columns[2].Width = 35 * 256;
            
            ws.Cells[row+=2,1].Value = ".Style.Borders.SetBorders(...)";
            ws.Cells[row,2].Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin);
            
            ws.Cells[row+=2,1].Value = ".Style.FillPattern.SetPattern(...)";
            ws.Cells[row,2].Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow);
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Color =";
            ws.Cells[row,2].Value = "Color.Blue";
            ws.Cells[row,2].Style.Font.Color = Color.Blue;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Italic =";
            ws.Cells[row,2].Value = "true";
            ws.Cells[row,2].Style.Font.Italic = true;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Name =";
            ws.Cells[row,2].Value = "Comic Sans MS";
            ws.Cells[row,2].Style.Font.Name = "Comic Sans MS";
            
            ws.Cells[row+=2,1].Value = ".Style.Font.ScriptPosition =";
            ws.Cells[row,2].Value = "ScriptPosition.Superscript";
            ws.Cells[row,2].Style.Font.ScriptPosition = ScriptPosition.Superscript;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Size =";
            ws.Cells[row,2].Value = "18 * 20";
            ws.Cells[row,2].Style.Font.Size = 18 * 20;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Strikeout =";
            ws.Cells[row,2].Value = "true";
            ws.Cells[row,2].Style.Font.Strikeout = true;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.UnderlineStyle =";
            ws.Cells[row,2].Value = "UnderlineStyle.Double";
            ws.Cells[row,2].Style.Font.UnderlineStyle = UnderlineStyle.Double;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Weight =";
            ws.Cells[row,2].Value = "ExcelFont.BoldWeight";
            ws.Cells[row,2].Style.Font.Weight = ExcelFont.BoldWeight;
            
            ws.Cells[row+=2,1].Value = ".Style.HorizontalAlignment =";
            ws.Cells[row,2].Value = "HorizontalAlignmentStyle.Center";
            ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Center;
            
            ws.Cells[row+=2,1].Value = ".Style.Indent";
            ws.Cells[row,2].Value = "five";
            ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Left;
            ws.Cells[row,2].Style.Indent = 5;
            
            ws.Cells[row+=2,1].Value = ".Style.IsTextVertical = ";
            ws.Cells[row,2].Value = "true";
            <font color="Green">// Set row height to 50 points.</font>
            ws.Rows[row].Height = 50 * 20;
            ws.Cells[row,2].Style.IsTextVertical = true;
            
            ws.Cells[row+=2,1].Value = ".Style.NumberFormat";
            ws.Cells[row,2].Value = 1234;
            ws.Cells[row,2].Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]";
            
            ws.Cells[row+=2,1].Value = ".Style.Rotation";
            ws.Cells[row,2].Value = "35 degrees up";
            ws.Cells[row,2].Style.Rotation = 35;
            
            ws.Cells[row+=2,1].Value = ".Style.ShrinkToFit";
            ws.Cells[row,2].Value = "This property is set to true so this text appears shrunk.";
            ws.Cells[row,2].Style.ShrinkToFit = true;
            
            ws.Cells[row+=2,1].Value = ".Style.VerticalAlignment =";
            ws.Cells[row,2].Value = "VerticalAlignmentStyle.Top";
            <font color="Green">// Set row height to 30 points.</font>
            ws.Rows[row].Height = 30 * 20;
            ws.Cells[row,2].Style.VerticalAlignment = VerticalAlignmentStyle.Top;
            
            ws.Cells[row+=2,1].Value = ".Style.WrapText";
            ws.Cells[row,2].Value = "This property is set to true so this text appears broken into multiple lines.";
            ws.Cells[row,2].Style.WrapText = true;
            }
            </code>
            </example>
            <seealso cref="P:MB.WinEIDrive.Excel.CellStyle.HorizontalAlignment"/>
        </member>
        <member name="P:MB.WinEIDrive.Excel.CellStyle.WrapText">
            <summary>
            Gets or sets if the text is wrapped.
            </summary>
            <remarks>
            <p>If set to <b>true</b>, wraps cell data into multiple lines in a cell. The number of wrapped lines is
            dependent on the width of the column and the length of the cell contents.</p>
            Default value for this property is <b>false</b>.
            </remarks>
            <example> Following code demonstrates various cell style properties:
            <code lang="Visual Basic">
            Sub StylesSample(ByVal ws As ExcelWorksheet)
            ws.Cells(0, 0).Value = "Cell style examples:"
            
            Dim row As Integer = 0
            
            <font color="Green">' Column width of 4, 30 and 35 characters.</font>
            ws.Columns(0).Width = 4 * 256
            ws.Columns(1).Width = 30 * 256
            ws.Columns(2).Width = 35 * 256
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Borders.SetBorders(...)"
            ws.Cells(row, 2).Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin)
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.FillPattern.SetPattern(...)"
            ws.Cells(row, 2).Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow)
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Color ="
            ws.Cells(row, 2).Value = "Color.Blue"
            ws.Cells(row, 2).Style.Font.Color = Color.Blue
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Italic ="
            ws.Cells(row, 2).Value = "true"
            ws.Cells(row, 2).Style.Font.Italic = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Name ="
            ws.Cells(row, 2).Value = "Comic Sans MS"
            ws.Cells(row, 2).Style.Font.Name = "Comic Sans MS"
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.ScriptPosition ="
            ws.Cells(row, 2).Value = "ScriptPosition.Superscript"
            ws.Cells(row, 2).Style.Font.ScriptPosition = ScriptPosition.Superscript
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Size ="
            ws.Cells(row, 2).Value = "18 * 20"
            ws.Cells(row, 2).Style.Font.Size = 18 * 20
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Strikeout ="
            ws.Cells(row, 2).Value = "true"
            ws.Cells(row, 2).Style.Font.Strikeout = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.UnderlineStyle ="
            ws.Cells(row, 2).Value = "UnderlineStyle.Double"
            ws.Cells(row, 2).Style.Font.UnderlineStyle = UnderlineStyle.Double
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Font.Weight ="
            ws.Cells(row, 2).Value = "ExcelFont.BoldWeight"
            ws.Cells(row, 2).Style.Font.Weight = ExcelFont.BoldWeight
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.HorizontalAlignment ="
            ws.Cells(row, 2).Value = "HorizontalAlignmentStyle.Center"
            ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Center
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Indent"
            ws.Cells(row, 2).Value = "five"
            ws.Cells(row, 2).Style.HorizontalAlignment = HorizontalAlignmentStyle.Left
            ws.Cells(row, 2).Style.Indent = 5
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.IsTextVertical = "
            ws.Cells(row, 2).Value = "true"
            <font color="Green">' Set row height to 50 points.</font>
            ws.Rows(row).Height = 50 * 20
            ws.Cells(row, 2).Style.IsTextVertical = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.NumberFormat"
            ws.Cells(row, 2).Value = 1234
            ws.Cells(row, 2).Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]"
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.Rotation"
            ws.Cells(row, 2).Value = "35 degrees up"
            ws.Cells(row, 2).Style.Rotation = 35
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.ShrinkToFit"
            ws.Cells(row, 2).Value = "This property is set to true so this text appears shrunk."
            ws.Cells(row, 2).Style.ShrinkToFit = True
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.VerticalAlignment ="
            ws.Cells(row, 2).Value = "VerticalAlignmentStyle.Top"
            <font color="Green">' Set row height to 30 points.</font>
            ws.Rows(row).Height = 30 * 20
            ws.Cells(row, 2).Style.VerticalAlignment = VerticalAlignmentStyle.Top
            
            row = row + 2
            ws.Cells(row, 1).Value = ".Style.WrapText"
            ws.Cells(row, 2).Value = "This property is set to true so this text appears broken into multiple lines."
            ws.Cells(row, 2).Style.WrapText = True
            End Sub
            </code>
            <code lang="C#">
            static void StylesSample(ExcelWorksheet ws)
            {
            ws.Cells[0,0].Value = "Cell style examples:";
            
            int row = 0;
            
            <font color="Green">// Column width of 4, 30 and 35 characters.</font>
            ws.Columns[0].Width = 4 * 256;
            ws.Columns[1].Width = 30 * 256;
            ws.Columns[2].Width = 35 * 256;
            
            ws.Cells[row+=2,1].Value = ".Style.Borders.SetBorders(...)";
            ws.Cells[row,2].Style.Borders.SetBorders(MultipleBorders.All, Color.FromArgb(252, 1, 1), LineStyle.Thin);
            
            ws.Cells[row+=2,1].Value = ".Style.FillPattern.SetPattern(...)";
            ws.Cells[row,2].Style.FillPattern.SetPattern(FillPatternStyle.ThinHorizontalCrosshatch, Color.Green, Color.Yellow);
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Color =";
            ws.Cells[row,2].Value = "Color.Blue";
            ws.Cells[row,2].Style.Font.Color = Color.Blue;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Italic =";
            ws.Cells[row,2].Value = "true";
            ws.Cells[row,2].Style.Font.Italic = true;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Name =";
            ws.Cells[row,2].Value = "Comic Sans MS";
            ws.Cells[row,2].Style.Font.Name = "Comic Sans MS";
            
            ws.Cells[row+=2,1].Value = ".Style.Font.ScriptPosition =";
            ws.Cells[row,2].Value = "ScriptPosition.Superscript";
            ws.Cells[row,2].Style.Font.ScriptPosition = ScriptPosition.Superscript;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Size =";
            ws.Cells[row,2].Value = "18 * 20";
            ws.Cells[row,2].Style.Font.Size = 18 * 20;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Strikeout =";
            ws.Cells[row,2].Value = "true";
            ws.Cells[row,2].Style.Font.Strikeout = true;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.UnderlineStyle =";
            ws.Cells[row,2].Value = "UnderlineStyle.Double";
            ws.Cells[row,2].Style.Font.UnderlineStyle = UnderlineStyle.Double;
            
            ws.Cells[row+=2,1].Value = ".Style.Font.Weight =";
            ws.Cells[row,2].Value = "ExcelFont.BoldWeight";
            ws.Cells[row,2].Style.Font.Weight = ExcelFont.BoldWeight;
            
            ws.Cells[row+=2,1].Value = ".Style.HorizontalAlignment =";
            ws.Cells[row,2].Value = "HorizontalAlignmentStyle.Center";
            ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Center;
            
            ws.Cells[row+=2,1].Value = ".Style.Indent";
            ws.Cells[row,2].Value = "five";
            ws.Cells[row,2].Style.HorizontalAlignment = HorizontalAlignmentStyle.Left;
            ws.Cells[row,2].Style.Indent = 5;
            
            ws.Cells[row+=2,1].Value = ".Style.IsTextVertical = ";
            ws.Cells[row,2].Value = "true";
            <font color="Green">// Set row height to 50 points.</font>
            ws.Rows[row].Height = 50 * 20;
            ws.Cells[row,2].Style.IsTextVertical = true;
            
            ws.Cells[row+=2,1].Value = ".Style.NumberFormat";
            ws.Cells[row,2].Value = 1234;
            ws.Cells[row,2].Style.NumberFormat = "#.##0,00 [$Krakozhian Money Units]";
            
            ws.Cells[row+=2,1].Value = ".Style.Rotation";
            ws.Cells[row,2].Value = "35 degrees up";
            ws.Cells[row,2].Style.Rotation = 35;
            
            ws.Cells[row+=2,1].Value = ".Style.ShrinkToFit";
            ws.Cells[row,2].Value = "This property is set to true so this text appears shrunk.";
            ws.Cells[row,2].Style.ShrinkToFit = true;
            
            ws.Cells[row+=2,1].Value = ".Style.VerticalAlignment =";
            ws.Cells[row,2].Value = "VerticalAlignmentStyle.Top";
            <font color="Green">// Set row height to 30 points.</font>
            ws.Rows[row].Height = 30 * 20;
            ws.Cells[row,2].Style.VerticalAlignment = VerticalAlignmentStyle.Top;
            
            ws.Cells[row+=2,1].Value = ".Style.WrapText";
            ws.Cells[row,2].Value = "This property is set to true so this text appears broken into multiple lines.";
            ws.Cells[row,2].Style.WrapText = true;
            }
            </code>
            </example>
        </member>
        <member name="T:MB.WinEIDrive.Excel.HashtableElement">
            <summary>
            HashtableElement. All derived classes MUST implement:
            1) HashtableElement Clone()
            2) int GetHashCode()
            3) bool Equals(object obj)
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.Excel.ControlFormulaToken">
            <summary>
            Formula token for holding control value.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ControlFormulaToken.#ctor(MB.WinEIDrive.Excel.FormulaTokenCode)">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.ControlFormulaToken"/> class.
            </summary>
            <param name="code">The FormulaTokenCode code.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ControlFormulaToken.ConvertToBytes">
            <summary>
            Convert formula token to array of byte representation.
            </summary>
            <returns>formula token' array of byte representation</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ControlFormulaToken.Read(System.Byte[],System.Int32)">
            <summary>
            Initialize formula token by reading input data from array of bytes
            </summary>
            <param name="rpnBytes">input data, array of bytes</param>
            <param name="startIndex">start position for array of bytes to read from</param>
        </member>
        <member name="T:MB.WinEIDrive.Excel.CsvType">
            <summary>
            Formatting type for CSV files.
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.Excel.ErrFormulaToken">
            <summary>
            Formula token for holding error value.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ErrFormulaToken.#cctor">
            <summary>
            Initializes the <see cref="T:MB.WinEIDrive.Excel.ErrFormulaToken"/> class.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ErrFormulaToken.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.ErrFormulaToken"/> class.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ErrFormulaToken.ConvertToBytes">
            <summary>
            Convert formula token to array of byte representation.
            </summary>
            <returns>formula token' array of byte representation</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ErrFormulaToken.DelayInitialize(System.Object[])">
            <summary>
            Make custom delay initialize.
            </summary>
            <param name="data">The data for initialization which is unique for each formula token.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ErrFormulaToken.Read(System.Byte[],System.Int32)">
            <summary>
            Initialize formula token by reading input data from array of bytes
            </summary>
            <param name="rpnBytes">input data, array of bytes</param>
            <param name="startIndex">start position for array of bytes to read from</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ErrFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="T:MB.WinEIDrive.Excel.ExcelCell">
            <summary>
            Excel cell provides access to a single worksheet cell or to a merged range if the cell is merged.
            </summary>
            <remarks>
            <p>Merged range is created by using <see cref="P:MB.WinEIDrive.Excel.CellRange.Merged">CellRange.Merged</see> property.
            See the property documentation for more information on merging.</p>
            </remarks>
            <seealso cref="P:MB.WinEIDrive.Excel.CellRange.Merged">CellRange.Merged</seealso>
            <seealso cref="P:MB.WinEIDrive.Excel.ExcelCell.MergedRange"/>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ExcelCell.ConvertExcelNumberToDateTime(System.Double)">
            <summary>
            Converts Excel floating-point number to <see cref="T:System.DateTime">DateTime</see> structure.
            </summary>
            <remarks>
            <p>
            Excel file format doesn't have a separate data type for date and time.
            <see cref="T:System.DateTime">DateTime</see> value is
            stored as IEEE number encoded in a special way. When reading Excel file,
            <see cref="P:MB.WinEIDrive.Excel.CellStyle.NumberFormat">CellStyle.NumberFormat</see> is examined and if it matches
            some of date/time number formats cell value is interpreted as <see cref="T:System.DateTime">DateTime</see>.</p>
            <p>However, if some non-standard date/time number format is used, cell value will not be recognized
            as <see cref="T:System.DateTime">DateTime</see> but as ordinary number. In such cases (when you know that
            specific cell holds <see cref="T:System.DateTime">DateTime</see> value but you get a number when reading
            Excel file) use this method to convert IEEE number to <see cref="T:System.DateTime">DateTime</see>
            structure.</p>
            </remarks>
            <param name="num">Excel floating-point number.</param>
            <returns>Converted DateTime structure.</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ExcelCell.SetBorders(MB.WinEIDrive.Excel.MultipleBorders,System.Drawing.Color,MB.WinEIDrive.Excel.LineStyle)">
            <summary>
            Sets borders on this cell or on merged range if this cell is merged.
            </summary>
            <param name="multipleBorders">Borders to set.</param>
            <param name="lineColor">Line color.</param>
            <param name="lineStyle">Line style.</param>
            <seealso cref="P:MB.WinEIDrive.Excel.CellRange.Merged">CellRange.Merged</seealso>
            <seealso cref="P:MB.WinEIDrive.Excel.ExcelCell.MergedRange"/>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelCell.Formula">
            <summary>
            Gets or sets cell formula string.
            </summary>
            <remarks>
            <p>ExcelLite can read and write formulas, but can not calculate formula results. When you open a XLS file in
            MS Excel, formula results will be calculated automaticaly.</p>
            <p>During setting formula string ExcelLite formula parser will use English culture to parse numbers.</p>
            <p>Currently supported formula features are:
            <list type="bullet">
            <item><description>Named cell</description></item>
            <item><description>Named range</description></item>
            <item><description>Absolute cell/range</description></item>
            <item><description>Relative cell/range</description></item>
            <item><description>Functions( partly, see the list of supported functions below )</description></item>
            <item><description>Missed argument</description></item>
            <item><description>Unary operator</description></item>
            <item><description>Binary operator</description></item>
            <item><description>Parentheses</description></item>
            <item><description>3d cell reference</description></item>
            <item><description>3d cell range reference</description></item>
            <item><description>Boolean</description></item>
            <item><description>Integer</description></item>
            <item><description>Float</description></item>
            <item><description>String</description></item>
            <item><description>Error</description></item>
            </list>
            </p>
            <p>
            Currently unsupported formula features are:
            <list type="bullet">
            <item><description>Const array</description></item>
            <item><description>Array formula</description></item>
            <item><description>R1C1 reference</description></item>
            </list>
            </p>
            <p>
            Currently supported functions are:
            <list type="bullet">
            <item><description>NOW</description></item>
            <item><description>SECOND</description></item>
            <item><description>MINUTE</description></item>
            <item><description>HOUR</description></item>
            <item><description>WEEKDAY</description></item>
            <item><description>YEAR</description></item>
            <item><description>MONTH</description></item>
            <item><description>DAY</description></item>
            <item><description>TIME</description></item>
            <item><description>DATE</description></item>
            <item><description>RAND</description></item>
            <item><description>TEXT</description></item>
            <item><description>VAR</description></item>
            <item><description>MOD</description></item>
            <item><description>NOT</description></item>
            <item><description>OR</description></item>
            <item><description>AND</description></item>
            <item><description>FALSE</description></item>
            <item><description>TRUE</description></item>
            <item><description>VALUE</description></item>
            <item><description>LEN</description></item>
            <item><description>MID</description></item>
            <item><description>ROUND</description></item>
            <item><description>SIGN</description></item>
            <item><description>INT</description></item>
            <item><description>ABS</description></item>
            <item><description>LN</description></item>
            <item><description>EXP</description></item>
            <item><description>SQRT</description></item>
            <item><description>PI</description></item>
            <item><description>COS</description></item>
            <item><description>SIN</description></item>
            <item><description>COLUMN</description></item>
            <item><description>ROW</description></item>
            <item><description>MAX</description></item>
            <item><description>MIN</description></item>
            <item><description>AVERAGE</description></item>
            <item><description>SUM</description></item>
            <item><description>IF</description></item>
            <item><description>COUNT</description></item>
            </list>
            </p>
            <p>
            For more information on formulas, consult Microsoft Excel documentation.
            </p>
            </remarks>
            <example>Following code demonstrates how to use formulas and named ranges. It shows next features:
            cell references (both absolute and relative), unary and binary operators, constand operands (integer and floating point),
            functions and named cell ranges.
            <code lang="Visual Basic">
            ws.Cells("A1").Value = 5
            ws.Cells("A2").Value = 6
            ws.Cells("A3").Value = 10
            
            ws.Cells("C1").Formula = "=A1+A2"
            ws.Cells("C2").Formula = "=$A$1-A3"
            ws.Cells("C3").Formula = "=COUNT(A1:A3)"
            ws.Cells("C4").Formula = "=AVERAGE($A$1:$A$3)"
            ws.Cells("C5").Formula = "=SUM(A1:A3,2,3)"
            ws.Cells("C7").Formula = "= 123 - (-(-(23.5)))"
            
            ws.NamedRanges.Add("DataRange", ws.Cells.GetSubrange("A1", "A3"))
            ws.Cells("C8").Formula = "=MAX(DataRange)"
            
            Dim cr As CellRange = ws.Cells.GetSubrange("B9","C10")
            cr.Merged = True
            cr.Formula = "=A1*25"
            </code>
            <code lang="C#">
            ws.Cells["A1"].Value = 5;
            ws.Cells["A2"].Value = 6;
            ws.Cells["A3"].Value = 10;
            
            ws.Cells["C1"].Formula = "=A1+A2";
            ws.Cells["C2"].Formula = "=$A$1-A3";
            ws.Cells["C3"].Formula = "=COUNT(A1:A3)";
            ws.Cells["C4"].Formula = "=AVERAGE($A$1:$A$3)";
            ws.Cells["C5"].Formula = "=SUM(A1:A3,2,3)";
            ws.Cells["C7"].Formula = "= 123 - (-(-(23.5)))";
            
            ws.NamedRanges.Add("DataRange", ws.Cells.GetSubrange("A1", "A3"));
            ws.Cells["C8"].Formula = "=MAX(DataRange)";
            
            CellRange cr = ws.Cells.GetSubrange("B9", "C10");
            cr.Merged = true;
            cr.Formula = "=A1*25";
            </code>
            </example>
            <seealso cref="M:MB.WinEIDrive.Excel.NamedRangeCollection.Add(System.String,MB.WinEIDrive.Excel.CellRange)">NamedRangeCollection.Add</seealso>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelCell.IsStyleDefault">
            <summary>
            Returns <b>true</b> if style is default; otherwise, <b>false</b>.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelCell.MergedRange">
            <summary>
            Returns associated merged range if the cell is merged; otherwise, <b>null</b>.
            </summary>
            <seealso cref="P:MB.WinEIDrive.Excel.CellRange.Merged">CellRange.Merged</seealso>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelCell.Style">
            <summary>
            Gets or sets cell style (<see cref="T:MB.WinEIDrive.Excel.CellStyle">CellStyle</see>) of this cell or
            of merged range if this cell is merged.
            </summary>
            <remarks>
            Unset style properties will be inherited from corresponding row or column. See
            <see cref="P:MB.WinEIDrive.Excel.ExcelFile.RowColumnResolutionMethod">ExcelFile.RowColumnResolutionMethod</see>
            for more details.
            </remarks>
            <seealso cref="P:MB.WinEIDrive.Excel.CellRange.Merged">CellRange.Merged</seealso>
            <seealso cref="P:MB.WinEIDrive.Excel.ExcelCell.MergedRange"/>
            <seealso cref="P:MB.WinEIDrive.Excel.ExcelFile.RowColumnResolutionMethod">ExcelFile.RowColumnResolutionMethod</seealso>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelCell.Value">
            <summary>
            Gets or sets value of this cell or of merged range if this cell is merged.
            </summary>
            <remarks>
            <p>Exception is thrown if value for the set is not of supported type (See
            <see cref="M:MB.WinEIDrive.Excel.ExcelFile.SupportsType(System.Type)">ExcelFile.SupportsType</see> for details).</p>
            <p>Note that the fact some type is supported doesn't mean it is written to Excel file in the native format. As
            Microsoft Excel has just few basic types, the object of supported type will be converted to a similar excel type.
            If similar excel type doesn't exist, value is written as a string value.</p>
            <p>If the value of this property is of <see cref="T:System.DateTime">DateTime</see> type and
            <see cref="P:MB.WinEIDrive.Excel.ExcelCell.Style">Style</see> number format is not set, ISO date/time
            format will be used as <see cref="P:MB.WinEIDrive.Excel.CellStyle.NumberFormat">CellStyle.NumberFormat</see>
            value.</p>
            </remarks>
            <exception cref="T:System.NotSupportedException">Thrown for unsupported types.</exception>
            <seealso cref="P:MB.WinEIDrive.Excel.CellRange.Merged">CellRange.Merged</seealso>
            <seealso cref="P:MB.WinEIDrive.Excel.ExcelCell.MergedRange"/>
            <seealso cref="M:MB.WinEIDrive.Excel.ExcelFile.SupportsType(System.Type)">ExcelFile.SupportsType</seealso>
            <seealso cref="P:MB.WinEIDrive.Excel.CellStyle.NumberFormat">CellStyle.NumberFormat</seealso>
        </member>
        <member name="T:MB.WinEIDrive.Excel.ExcelCellCollection">
            <summary>
            Collection of excel cells (<see cref="T:MB.WinEIDrive.Excel.ExcelCell">ExcelCell</see>).
            </summary>
            <seealso cref="T:MB.WinEIDrive.Excel.ExcelCell"/>
        </member>
        <member name="T:MB.WinEIDrive.Excel.ExcelRowColumnCellCollectionBase">
            <summary>
            Base class for row, column and cell collections.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ExcelRowColumnCellCollectionBase.#ctor(MB.WinEIDrive.Excel.ExcelWorksheet)">
            <summary>
            Internal.
            </summary>
            <param name="parent"></param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ExcelRowColumnCellCollectionBase.GetEnumerator">
            <summary>
            Returns an enumerator for the <see cref="T:MB.WinEIDrive.Excel.ExcelRowColumnCellCollectionBase">
            ExcelRowColumnCellCollectionBase</see>.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelRowColumnCellCollectionBase.Count">
            <summary>
            Gets the number of currently allocated elements (dynamically changes when worksheet is modified).
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelRowColumnCellCollectionBase.Items">
            <summary>
            Internal.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelCellCollection.Item(System.Int32)">
            <summary>
            Gets the cell with the specified index.
            </summary>
            <param name="index">The zero-based index of the cell.</param>
        </member>
        <member name="T:MB.WinEIDrive.Excel.ExcelColumn">
            <summary>
            Excel column contains column options and cell range with column cells.
            </summary>
            <seealso cref="T:MB.WinEIDrive.Excel.ExcelRow"/>
        </member>
        <member name="T:MB.WinEIDrive.Excel.ExcelColumnRowBase">
            <summary>
            Base class for the excel column and row classes.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ExcelColumnRowBase.#ctor(MB.WinEIDrive.Excel.ExcelRowColumnCollectionBase,MB.WinEIDrive.Excel.ExcelColumnRowBase)">
            <summary>
            Internal. Copy constructor.
            </summary>
            <param name="parent"></param>
            <param name="source"></param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ExcelColumnRowBase.#ctor(MB.WinEIDrive.Excel.ExcelRowColumnCollectionBase,System.Int32)">
            <summary>
            Internal.
            </summary>
            <param name="parent"></param>
            <param name="index"></param>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelColumnRowBase.Collapsed">
            <summary>
            Gets or sets whether object is collapsed in outlining.
            </summary>
            <example> Following code creates two horizontal groups and one vertical group. Horizontal groups have
            outline button above (default is below), while vertical group is collapsed.
            <code lang="Visual Basic">
            Sub GroupingSample(ByVal ws As ExcelWorksheet)
            ws.Cells(0, 0).Value = "Grouping and outline example:"
            
            <font color="Green">' Vertical grouping.</font>
            ws.Cells(2, 0).Value = "GroupA Start"
            ws.Rows(2).OutlineLevel = 1
            ws.Cells(3, 0).Value = "A"
            ws.Rows(3).OutlineLevel = 1
            ws.Cells(4, 1).Value = "GroupB Start"
            ws.Rows(4).OutlineLevel = 2
            ws.Cells(5, 1).Value = "B"
            ws.Rows(5).OutlineLevel = 2
            ws.Cells(6, 1).Value = "GroupB End"
            ws.Rows(6).OutlineLevel = 2
            ws.Cells(7, 0).Value = "GroupA End"
            ws.Rows(7).OutlineLevel = 1
            <font color="Green">' Put outline row buttons above groups.</font>
            ws.OutlineRowButtonsBelow = False
            
            <font color="Green">' Horizontal grouping (collapsed).</font>
            ws.Cells("E2").Value = "Gr.C Start"
            ws.Columns("E").OutlineLevel = 1
            ws.Columns("E").Collapsed = True
            ws.Cells("F2").Value = "C"
            ws.Columns("F").OutlineLevel = 1
            ws.Columns("F").Collapsed = True
            ws.Cells("G2").Value = "Gr.C End"
            ws.Columns("G").OutlineLevel = 1
            ws.Columns("G").Collapsed = True
            End Sub
            </code>
            <code lang="C#">
            static void GroupingSample(ExcelWorksheet ws)
            {
            ws.Cells[0,0].Value = "Grouping and outline example:";
            
            <font color="Green">// Vertical grouping.</font>
            ws.Cells[2,0].Value = "GroupA Start";
            ws.Rows[2].OutlineLevel = 1;
            ws.Cells[3,0].Value = "A";
            ws.Rows[3].OutlineLevel = 1;
            ws.Cells[4,1].Value = "GroupB Start";
            ws.Rows[4].OutlineLevel = 2;
            ws.Cells[5,1].Value = "B";
            ws.Rows[5].OutlineLevel = 2;
            ws.Cells[6,1].Value = "GroupB End";
            ws.Rows[6].OutlineLevel = 2;
            ws.Cells[7,0].Value = "GroupA End";
            ws.Rows[7].OutlineLevel = 1;
            <font color="Green">// Put outline row buttons above groups.</font>
            ws.OutlineRowButtonsBelow = false;
            
            <font color="Green">// Horizontal grouping (collapsed).</font>
            ws.Cells["E2"].Value = "Gr.C Start";
            ws.Columns["E"].OutlineLevel = 1;
            ws.Columns["E"].Collapsed = true;
            ws.Cells["F2"].Value = "C";
            ws.Columns["F"].OutlineLevel = 1;
            ws.Columns["F"].Collapsed = true;
            ws.Cells["G2"].Value = "Gr.C End";
            ws.Columns["G"].OutlineLevel = 1;
            ws.Columns["G"].Collapsed = true;
            }
            </code>
            </example>
            <seealso cref="P:MB.WinEIDrive.Excel.ExcelColumnRowBase.OutlineLevel"/>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelColumnRowBase.IsStyleDefault">
            <summary>
            Returns <b>true</b> if style is default; otherwise, <b>false</b>.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelColumnRowBase.OutlineLevel">
            <summary>
            Gets or sets outline level.
            </summary>
            <remarks>
            <p>Exception is thrown if value is out of 0 to 7 range.</p>
            <p>Using this property you can create hierarchical groups. Range of consecutive objects (rows or columns)
            with the same value of outline level belongs to the same group. Default value is zero, which prevents grouping.
            <see cref="P:MB.WinEIDrive.Excel.ExcelColumnRowBase.Collapsed">Collapsed</see> property determines whether group
            is collapsed or expanded in outlining.</p>
            </remarks>
            <example> Following code creates two horizontal groups and one vertical group. Horizontal groups have
            outline button above (default is below), while vertical group is collapsed.
            <code lang="Visual Basic">
            Sub GroupingSample(ByVal ws As ExcelWorksheet)
            ws.Cells(0, 0).Value = "Grouping and outline example:"
            
            <font color="Green">' Vertical grouping.</font>
            ws.Cells(2, 0).Value = "GroupA Start"
            ws.Rows(2).OutlineLevel = 1
            ws.Cells(3, 0).Value = "A"
            ws.Rows(3).OutlineLevel = 1
            ws.Cells(4, 1).Value = "GroupB Start"
            ws.Rows(4).OutlineLevel = 2
            ws.Cells(5, 1).Value = "B"
            ws.Rows(5).OutlineLevel = 2
            ws.Cells(6, 1).Value = "GroupB End"
            ws.Rows(6).OutlineLevel = 2
            ws.Cells(7, 0).Value = "GroupA End"
            ws.Rows(7).OutlineLevel = 1
            <font color="Green">' Put outline row buttons above groups.</font>
            ws.OutlineRowButtonsBelow = False
            
            <font color="Green">' Horizontal grouping (collapsed).</font>
            ws.Cells("E2").Value = "Gr.C Start"
            ws.Columns("E").OutlineLevel = 1
            ws.Columns("E").Collapsed = True
            ws.Cells("F2").Value = "C"
            ws.Columns("F").OutlineLevel = 1
            ws.Columns("F").Collapsed = True
            ws.Cells("G2").Value = "Gr.C End"
            ws.Columns("G").OutlineLevel = 1
            ws.Columns("G").Collapsed = True
            End Sub
            </code>
            <code lang="C#">
            static void GroupingSample(ExcelWorksheet ws)
            {
            ws.Cells[0,0].Value = "Grouping and outline example:";
            
            <font color="Green">// Vertical grouping.</font>
            ws.Cells[2,0].Value = "GroupA Start";
            ws.Rows[2].OutlineLevel = 1;
            ws.Cells[3,0].Value = "A";
            ws.Rows[3].OutlineLevel = 1;
            ws.Cells[4,1].Value = "GroupB Start";
            ws.Rows[4].OutlineLevel = 2;
            ws.Cells[5,1].Value = "B";
            ws.Rows[5].OutlineLevel = 2;
            ws.Cells[6,1].Value = "GroupB End";
            ws.Rows[6].OutlineLevel = 2;
            ws.Cells[7,0].Value = "GroupA End";
            ws.Rows[7].OutlineLevel = 1;
            <font color="Green">// Put outline row buttons above groups.</font>
            ws.OutlineRowButtonsBelow = false;
            
            <font color="Green">// Horizontal grouping (collapsed).</font>
            ws.Cells["E2"].Value = "Gr.C Start";
            ws.Columns["E"].OutlineLevel = 1;
            ws.Columns["E"].Collapsed = true;
            ws.Cells["F2"].Value = "C";
            ws.Columns["F"].OutlineLevel = 1;
            ws.Columns["F"].Collapsed = true;
            ws.Cells["G2"].Value = "Gr.C End";
            ws.Columns["G"].OutlineLevel = 1;
            ws.Columns["G"].Collapsed = true;
            }
            </code>
            </example>
            <seealso cref="P:MB.WinEIDrive.Excel.ExcelColumnRowBase.Collapsed"/>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if value is out of 0 to 7 range.</exception>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelColumnRowBase.Style">
            <summary>
            Gets or sets cell style (<see cref="T:MB.WinEIDrive.Excel.CellStyle">CellStyle</see>) for contained cells.
            </summary>
            <remarks>
            Setting this property will not directly change <see cref="P:MB.WinEIDrive.Excel.ExcelCell.Style">ExcelCell.Style</see>.
            Instead, this style will be used in resolving process when writing Excel file. See
            <see cref="P:MB.WinEIDrive.Excel.ExcelFile.RowColumnResolutionMethod">ExcelFile.RowColumnResolutionMethod</see>
            for details.
            </remarks>
            <seealso cref="P:MB.WinEIDrive.Excel.ExcelFile.RowColumnResolutionMethod">ExcelFile.RowColumnResolutionMethod</seealso>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelColumn.Cells">
            <summary>
            Gets cell range with column cells.
            </summary>
            <example> Look at following code for cell referencing examples:
            <code lang="Visual Basic">
            Dim ws As ExcelWorksheet = excelFile.Worksheets.ActiveWorksheet
            
            ws.Cells("B2").Value = "Cell B2."
            ws.Cells(6, 0).Value = "Cell in row 7 and column A."
            
            ws.Rows(2).Cells(0).Value = "Cell in row 3 and column A."
            ws.Rows("4").Cells("B").Value = "Cell in row 4 and column B."
            
            ws.Columns(2).Cells(4).Value = "Cell in column C and row 5."
            ws.Columns("AA").Cells("6").Value = "Cell in AA column and row 6."
            </code>
            <code lang="C#">
            ExcelWorksheet ws = excelFile.Worksheets.ActiveWorksheet;
            
            ws.Cells["B2"].Value = "Cell B2.";
            ws.Cells[6,0].Value = "Cell in row 7 and column A.";
            
            ws.Rows[2].Cells[0].Value = "Cell in row 3 and column A.";
            ws.Rows["4"].Cells["B"].Value = "Cell in row 4 and column B.";
            
            ws.Columns[2].Cells[4].Value = "Cell in column C and row 5.";
            ws.Columns["AA"].Cells["6"].Value = "Cell in AA column and row 6.";
            </code>
            </example>
            <seealso cref="T:MB.WinEIDrive.Excel.ExcelCell"/>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelColumn.Hidden">
            <summary>
            Gets or sets whether column is hidden.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelColumn.Width">
            <summary>
            Gets or sets column width.
            </summary>
            <remarks>
            Unit is 1/256th of the width of the zero character in default font.
            </remarks>
            <seealso cref="P:MB.WinEIDrive.Excel.ExcelWorksheet.DefaultColumnWidth"/>
        </member>
        <member name="T:MB.WinEIDrive.Excel.ExcelColumnCollection">
            <summary>
            Collection of excel columns (<see cref="T:MB.WinEIDrive.Excel.ExcelColumn">ExcelColumn</see>).
            </summary>
            <seealso cref="T:MB.WinEIDrive.Excel.ExcelColumn"/>
        </member>
        <member name="T:MB.WinEIDrive.Excel.ExcelRowColumnCollectionBase">
            <summary>
            Base class for row and column collections.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ExcelRowColumnCollectionBase.#ctor(MB.WinEIDrive.Excel.ExcelWorksheet)">
            <summary>
            Internal.
            </summary>
            <param name="parent"></param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ExcelColumnCollection.ColumnIndexToName(System.Int32)">
            <summary>
            Converts column index (0, 1, ...) to column name ("A", "B", ...).
            </summary>
            <param name="columnIndex">Column index.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ExcelColumnCollection.ColumnNameToIndex(System.String)">
            <summary>
            Converts column name ("A", "B", ...) to column index (0, 1, ...).
            </summary>
            <param name="name">Column name.</param>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelColumnCollection.Item(System.String)">
            <summary>
            Gets the column with the specified name.
            </summary>
            <param name="name">The name of the column.</param>
            <example> Look at following code for cell referencing examples:
            <code lang="Visual Basic">
            Dim ws As ExcelWorksheet = excelFile.Worksheets.ActiveWorksheet
            
            ws.Cells("B2").Value = "Cell B2."
            ws.Cells(6, 0).Value = "Cell in row 7 and column A."
            
            ws.Rows(2).Cells(0).Value = "Cell in row 3 and column A."
            ws.Rows("4").Cells("B").Value = "Cell in row 4 and column B."
            
            ws.Columns(2).Cells(4).Value = "Cell in column C and row 5."
            ws.Columns("AA").Cells("6").Value = "Cell in AA column and row 6."
            </code>
            <code lang="C#">
            ExcelWorksheet ws = excelFile.Worksheets.ActiveWorksheet;
            
            ws.Cells["B2"].Value = "Cell B2.";
            ws.Cells[6,0].Value = "Cell in row 7 and column A.";
            
            ws.Rows[2].Cells[0].Value = "Cell in row 3 and column A.";
            ws.Rows["4"].Cells["B"].Value = "Cell in row 4 and column B.";
            
            ws.Columns[2].Cells[4].Value = "Cell in column C and row 5.";
            ws.Columns["AA"].Cells["6"].Value = "Cell in AA column and row 6.";
            </code>
            </example>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelColumnCollection.Item(System.Int32)">
            <overloads>Gets the column with the specified index or name.</overloads>
            <summary>
            Gets the column with the specified index.
            </summary>
            <param name="index">The zero-based index of the column.</param>
            <example> Look at following code for cell referencing examples:
            <code lang="Visual Basic">
            Dim ws As ExcelWorksheet = excelFile.Worksheets.ActiveWorksheet
            
            ws.Cells("B2").Value = "Cell B2."
            ws.Cells(6, 0).Value = "Cell in row 7 and column A."
            
            ws.Rows(2).Cells(0).Value = "Cell in row 3 and column A."
            ws.Rows("4").Cells("B").Value = "Cell in row 4 and column B."
            
            ws.Columns(2).Cells(4).Value = "Cell in column C and row 5."
            ws.Columns("AA").Cells("6").Value = "Cell in AA column and row 6."
            </code>
            <code lang="C#">
            ExcelWorksheet ws = excelFile.Worksheets.ActiveWorksheet;
            
            ws.Cells["B2"].Value = "Cell B2.";
            ws.Cells[6,0].Value = "Cell in row 7 and column A.";
            
            ws.Rows[2].Cells[0].Value = "Cell in row 3 and column A.";
            ws.Rows["4"].Cells["B"].Value = "Cell in row 4 and column B.";
            
            ws.Columns[2].Cells[4].Value = "Cell in column C and row 5.";
            ws.Columns["AA"].Cells["6"].Value = "Cell in AA column and row 6.";
            </code>
            </example>
        </member>
        <member name="T:MB.WinEIDrive.Excel.ExcelFile">
            <summary>
            Excel file contains one or more worksheets (<see cref="T:MB.WinEIDrive.Excel.ExcelWorksheet">ExcelWorksheet</see>)
            and workbook related properties and methods.
            </summary>
            <seealso cref="T:MB.WinEIDrive.Excel.ExcelWorksheet"/>
        </member>
        <member name="F:MB.WinEIDrive.Excel.ExcelFile.MaxCellStyles">
            <summary>
            Maximum number of user-defined cell styles in Microsoft Excel.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.ExcelFile.MaxColors">
            <summary>
            Maximum number of colors in Microsoft Excel.
            </summary>
            <remarks>
            This number includes 8 default colors:
            <see cref="P:System.Drawing.Color.Black">Color.Black</see>,
            <see cref="P:System.Drawing.Color.White">Color.White</see>,
            <see cref="P:System.Drawing.Color.Red">Color.Red</see>,
            <see cref="P:System.Drawing.Color.Green">Color.Green</see>,
            <see cref="P:System.Drawing.Color.Blue">Color.Blue</see>,
            <see cref="P:System.Drawing.Color.Yellow">Color.Yellow</see>,
            <see cref="P:System.Drawing.Color.Magenta">Color.Magenta</see> and
            <see cref="P:System.Drawing.Color.Cyan">Color.Cyan</see>.
            </remarks>
        </member>
        <member name="F:MB.WinEIDrive.Excel.ExcelFile.MaxColumns">
            <summary>
            Maximum number of columns in <see cref="T:MB.WinEIDrive.Excel.ExcelWorksheet">ExcelWorksheet</see>.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.ExcelFile.MaxRows">
            <summary>
            Maximum number of rows in <see cref="T:MB.WinEIDrive.Excel.ExcelWorksheet">ExcelWorksheet</see>.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ExcelFile.DumpToLowLevelXml(System.String,System.String)">
            <summary>
            Internal.
            </summary>
            <param name="sourceFileName">Source file name.</param>
            <param name="destinationFileName">Destination file name.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ExcelFile.LoadCsv(System.String,MB.WinEIDrive.Excel.CsvType)">
            <overloads>Loads the existing CSV file</overloads>
            <summary>
            Loads the existing CSV file with specified format.
            </summary>
            <param name="fileName">Existing CSV file name (opened for reading).</param>
            <param name="csvType">CSV type.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ExcelFile.LoadCsv(System.String,System.Char)">
            <summary>
            Loads the existing CSV file, using specified character as a delimiter.
            </summary>
            <param name="fileName">File name.</param>
            <param name="separator">Separator used for delimiting data values.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ExcelFile.LoadXls(System.String)">
            <overloads>Loads the existing XLS file</overloads>
            <summary>
            Loads the existing XLS file (preserving MS Excel records).
            </summary>
            <param name="fileName">Existing XLS file name (opened for reading).</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ExcelFile.LoadXls(System.String,MB.WinEIDrive.Excel.XlsOptions)">
            <summary>
            Loads the existing XLS file (optionally preserving MS Excel records).
            </summary>
            <remarks>
            <p>If the only purpose of loading the file is to read data values and formatting using
            ExcelLite API, you should use <i>xlsOptions</i> set to <see cref="F:MB.WinEIDrive.Excel.XlsOptions.None">XlsOptions.None</see>
            as this will speed up the loading process.</p>
            <p>If you load the existing file to use it as template for a new file, you can choose
            whether you want to preserve specific MS Excel records not recognized by ExcelLite API.</p>
            </remarks>
            <param name="fileName">Existing XLS file name (opened for reading).</param>
            <param name="xlsOptions">XLS options.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ExcelFile.SaveCsv(System.String,MB.WinEIDrive.Excel.CsvType)">
            <overloads>Saves all data to a new file in CSV format.</overloads>
            <summary>
            Saves all data to a new file in a specified CSV format.
            </summary>
            <param name="fileName">File name.</param>
            <param name="csvType">CSV type.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ExcelFile.SaveCsv(System.String,System.Char)">
            <summary>
            Saves all data to a new CSV file, using specified character as a delimiter.
            </summary>
            <param name="fileName">File name.</param>
            <param name="separator">Separator used for delimiting data values.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ExcelFile.SaveXls(System.String)">
            <summary>
            Saves all data to a new file in XLS format.
            </summary>
            <param name="fileName">File name.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ExcelFile.SupportsType(System.Type)">
            <summary>
            Gets a value indicating whether the objects of specified type can be assigned
            to <see cref="P:MB.WinEIDrive.Excel.ExcelCell.Value">ExcelCell.Value</see> property.
            </summary>
            <param name="type">Queried type.</param>
            <remarks>
            Currently supported types are:
            <list type="bullet">
            <item><description>System.DBNull</description></item>
            <item><description>System.Byte</description></item>
            <item><description>System.SByte</description></item>
            <item><description>System.Int16</description></item>
            <item><description>System.UInt16</description></item>
            <item><description>System.Int64</description></item>
            <item><description>System.UInt64</description></item>
            <item><description>System.UInt32</description></item>
            <item><description>System.Int32</description></item>
            <item><description>System.Single</description></item>
            <item><description>System.Double</description></item>
            <item><description>System.Boolean</description></item>
            <item><description>System.Char</description></item>
            <item><description>System.Text.StringBuilder</description></item>
            <item><description>System.Decimal</description></item>
            <item><description>System.DateTime</description></item>
            <item><description>System.String</description></item>
            </list>
            </remarks>
            <returns><b>true</b> if the specified type is supported; otherwise, <b>false</b>.</returns>
        </member>
        <member name="E:MB.WinEIDrive.Excel.ExcelFile.LimitNear">
            <summary>
            Occurs when the size of XLS / CSV file in reading / writing is near <b>ExcelLite Free</b> limit.
            </summary>
            <remarks>
            <p>This event is fired when 80% of maximum row count per worksheet is reached (150 * 0.8 = 120 rows) or
            when 5 worksheets are used.</p>
            <p>This event is not fired if <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitReached">LimitReached</see>
            event is fired.</p>
            <p>You can use this event to detect when your application is close to <b>ExcelLite Free</b> limit.
            For example, you can write number of used rows to a log file or send a notification e-mail.</p>
            </remarks>
            <example> Following code demonstrates how to handle <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitNear">LimitNear</see>
            and <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitReached">LimitReached</see> events in <b>ExcelLite Free</b>.
            This sample disables warning worksheet in <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitNear">LimitNear</see> event
            handler and displays console messages in
            <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitReached">LimitReached</see> event handler.
            <code lang="Visual Basic">
            Sub Main()
            Dim ef As ExcelFile = New ExcelFile
            
            AddHandler ef.LimitNear, AddressOf ef_LimitNear
            AddHandler ef.LimitReached, AddressOf ef_LimitReached
            
            Dim ws As ExcelWorksheet = ef.Worksheets.Add("Sheet1")
            
            Dim i As Integer
            For i = 0 To 172 - 1 Step i + 1
            ws.Cells(i, 0).Value = i
            Next
            
            ef.SaveXls("Test.xls")
            End Sub
            
            Private Sub ef_LimitNear(ByVal sender As Object, ByVal e As LimitEventArgs)
            e.WriteWarningWorksheet = False
            End Sub
            
            Private Sub ef_LimitReached(ByVal sender As Object, ByVal e As LimitEventArgs)
            Select Case e.Operation
            Case LimitEventOperation.XlsReading
            Console.WriteLine("Data truncated while reading XLS file: " + e.FileName)
            
            Case LimitEventOperation.CsvReading
            Console.WriteLine("Data truncated while reading CSV file: " + e.FileName)
            
            Case LimitEventOperation.XlsWriting
            Console.WriteLine("Data truncated while writing XLS file: " + e.FileName)
            e.WriteWarningWorksheet = False
            
            Case LimitEventOperation.CsvWriting
            Console.WriteLine("Data truncated while writing CSV file: " + e.FileName)
            
            End Select
            End Sub
            </code>
            <code lang="C#">
            static void Main(string[] args)
            {
            ExcelFile ef = new ExcelFile();
            
            ef.LimitNear += new LimitEventHandler(ef_LimitNear);
            ef.LimitReached += new LimitEventHandler(ef_LimitReached);
            
            ExcelWorksheet ws = ef.Worksheets.Add("Sheet1");
            
            for(int i=0; i!=172; i++)
            ws.Cells[i, 0].Value = i;
            
            ef.SaveXls("Test.xls");
            }
            
            private static void ef_LimitNear(object sender, LimitEventArgs e)
            {
            e.WriteWarningWorksheet = false;
            }
            
            private static void ef_LimitReached(object sender, LimitEventArgs e)
            {
            switch(e.Operation)
            {
            case LimitEventOperation.XlsReading:
            Console.WriteLine("Data truncated while reading XLS file: " + e.FileName);
            break;
            
            case LimitEventOperation.CsvReading:
            Console.WriteLine("Data truncated while reading CSV file: " + e.FileName);
            break;
            
            case LimitEventOperation.XlsWriting:
            Console.WriteLine("Data truncated while writing XLS file: " + e.FileName);
            e.WriteWarningWorksheet = false;
            break;
            
            case LimitEventOperation.CsvWriting:
            Console.WriteLine("Data truncated while writing CSV file: " + e.FileName);
            break;
            }
            }
            </code>
            </example>
            <seealso cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitReached"/>
        </member>
        <member name="E:MB.WinEIDrive.Excel.ExcelFile.LimitReached">
            <summary>
            Occurs when the size of XLS / CSV file in reading / writing is above <b>ExcelLite Free</b> limit.
            </summary>
            <remarks>
            <p>This event is fired when maximum row count per worksheet is reached (150 rows) or
            when more than 5 worksheets are used.</p>
            <p>You can use this event to notify a user of your application that data is
            only partially read / written.</p>
            </remarks>
            <example> Following code demonstrates how to handle <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitNear">LimitNear</see>
            and <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitReached">LimitReached</see> events in <b>ExcelLite Free</b>.
            This sample disables warning worksheet in <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitNear">LimitNear</see> event
            handler and displays console messages in
            <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitReached">LimitReached</see> event handler.
            <code lang="Visual Basic">
            Sub Main()
            Dim ef As ExcelFile = New ExcelFile
            
            AddHandler ef.LimitNear, AddressOf ef_LimitNear
            AddHandler ef.LimitReached, AddressOf ef_LimitReached
            
            Dim ws As ExcelWorksheet = ef.Worksheets.Add("Sheet1")
            
            Dim i As Integer
            For i = 0 To 172 - 1 Step i + 1
            ws.Cells(i, 0).Value = i
            Next
            
            ef.SaveXls("Test.xls")
            End Sub
            
            Private Sub ef_LimitNear(ByVal sender As Object, ByVal e As LimitEventArgs)
            e.WriteWarningWorksheet = False
            End Sub
            
            Private Sub ef_LimitReached(ByVal sender As Object, ByVal e As LimitEventArgs)
            Select Case e.Operation
            Case LimitEventOperation.XlsReading
            Console.WriteLine("Data truncated while reading XLS file: " + e.FileName)
            
            Case LimitEventOperation.CsvReading
            Console.WriteLine("Data truncated while reading CSV file: " + e.FileName)
            
            Case LimitEventOperation.XlsWriting
            Console.WriteLine("Data truncated while writing XLS file: " + e.FileName)
            e.WriteWarningWorksheet = False
            
            Case LimitEventOperation.CsvWriting
            Console.WriteLine("Data truncated while writing CSV file: " + e.FileName)
            
            End Select
            End Sub
            </code>
            <code lang="C#">
            static void Main(string[] args)
            {
            ExcelFile ef = new ExcelFile();
            
            ef.LimitNear += new LimitEventHandler(ef_LimitNear);
            ef.LimitReached += new LimitEventHandler(ef_LimitReached);
            
            ExcelWorksheet ws = ef.Worksheets.Add("Sheet1");
            
            for(int i=0; i!=172; i++)
            ws.Cells[i, 0].Value = i;
            
            ef.SaveXls("Test.xls");
            }
            
            private static void ef_LimitNear(object sender, LimitEventArgs e)
            {
            e.WriteWarningWorksheet = false;
            }
            
            private static void ef_LimitReached(object sender, LimitEventArgs e)
            {
            switch(e.Operation)
            {
            case LimitEventOperation.XlsReading:
            Console.WriteLine("Data truncated while reading XLS file: " + e.FileName);
            break;
            
            case LimitEventOperation.CsvReading:
            Console.WriteLine("Data truncated while reading CSV file: " + e.FileName);
            break;
            
            case LimitEventOperation.XlsWriting:
            Console.WriteLine("Data truncated while writing XLS file: " + e.FileName);
            e.WriteWarningWorksheet = false;
            break;
            
            case LimitEventOperation.CsvWriting:
            Console.WriteLine("Data truncated while writing CSV file: " + e.FileName);
            break;
            }
            }
            </code>
            </example>
            <seealso cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitNear"/>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelFile.GroupMethodsAffectedCellsLimit">
            <summary>
            Maximum number of affected cells in group set methods.
            </summary>
            <remarks>
            If user tries to modify all cells in a group which has more cells than specified limit, exception
            will be thrown. This property was introduced to prevent users from accidentally modifying millions
            of cells which results in a long delay, a large memory allocation and a big resulting file. You can
            set this limit to value which suits your needs (minimum is 5).
            </remarks>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelFile.Protected">
            <summary>
            Gets or sets the workbook protection flag.
            </summary>
            <remarks>
            This property is simply written to Excel file and has no effect on the behavior of this library.
            For more information on workbook protection, consult Microsoft Excel documentation.
            </remarks>
            <seealso cref="P:MB.WinEIDrive.Excel.ExcelWorksheet.Protected">ExcelWorksheet.Protected</seealso>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelFile.Worksheets">
            <summary>
            Collection of all worksheets (<see cref="T:MB.WinEIDrive.Excel.ExcelWorksheet">ExcelWorksheet</see>) in a workbook.
            </summary>
            <seealso cref="T:MB.WinEIDrive.Excel.ExcelWorksheet"/>
        </member>
        <member name="T:MB.WinEIDrive.Excel.ExcelFillPattern">
            <summary>
            Contains fill pattern settings.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ExcelFillPattern.SetPattern(MB.WinEIDrive.Excel.FillPatternStyle,System.Drawing.Color,System.Drawing.Color)">
            <summary>
            Sets complex (non-empty and non-solid) pattern.
            </summary>
            <param name="patternStyle">Pattern style.</param>
            <param name="foregroundColor">Foreground color.</param>
            <param name="backgroundColor">Background color.</param>
            <remarks>
            <p>For solid pattern, just use <see cref="M:MB.WinEIDrive.Excel.ExcelFillPattern.SetSolid(System.Drawing.Color)">SetSolid</see> method.</p>
            <p>To clear fill pattern, just set <see cref="P:MB.WinEIDrive.Excel.ExcelFillPattern.PatternStyle">PatternStyle</see>
            to <see cref="F:MB.WinEIDrive.Excel.FillPatternStyle.None">FillPatternStyle.None</see></p>
            </remarks>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ExcelFillPattern.SetSolid(System.Drawing.Color)">
            <summary>
            Sets solid pattern using specified fill color.
            </summary>
            <param name="fillColor">Fill color.</param>
            <remarks>
            This will set <see cref="P:MB.WinEIDrive.Excel.ExcelFillPattern.PatternStyle">PatternStyle</see> to
            <see cref="F:MB.WinEIDrive.Excel.FillPatternStyle.Solid">FillPatternStyle.Solid</see> and
            <see cref="P:MB.WinEIDrive.Excel.ExcelFillPattern.PatternForegroundColor">PatternForegroundColor</see>
            to <i>fillColor</i>.
            </remarks>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelFillPattern.PatternBackgroundColor">
            <summary>
            Get or sets fill pattern background color.
            </summary>
            <seealso cref="T:MB.WinEIDrive.Excel.FillPatternStyle"/>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelFillPattern.PatternForegroundColor">
            <summary>
            Get or sets fill pattern foreground color.
            </summary>
            <seealso cref="T:MB.WinEIDrive.Excel.FillPatternStyle"/>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelFillPattern.PatternStyle">
            <summary>
            Gets or sets fill pattern style.
            </summary>
            <remarks>
            If you set this property to anything else than <see cref="F:MB.WinEIDrive.Excel.FillPatternStyle.None">
            FillPatternStyle.None</see>, <see cref="P:MB.WinEIDrive.Excel.ExcelFillPattern.PatternForegroundColor">
            PatternForegroundColor</see> and/or <see cref="P:MB.WinEIDrive.Excel.ExcelFillPattern.PatternBackgroundColor">
            PatternBackgroundColor</see> should also be set (if color is
            different from default <see cref="P:System.Drawing.Color.Black">Color.Black</see>.
            </remarks>
        </member>
        <member name="T:MB.WinEIDrive.Excel.ExcelFont">
            <summary>
            Contains font related settings.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.ExcelFont.BoldWeight">
            <summary>
            Default bold font weight.
            </summary>
            <seealso cref="P:MB.WinEIDrive.Excel.ExcelFont.Weight"/>
        </member>
        <member name="F:MB.WinEIDrive.Excel.ExcelFont.MaxWeight">
            <summary>
            Maximum font weight.
            </summary>
            <seealso cref="P:MB.WinEIDrive.Excel.ExcelFont.Weight"/>
        </member>
        <member name="F:MB.WinEIDrive.Excel.ExcelFont.MinWeight">
            <summary>
            Minimum font weight.
            </summary>
            <seealso cref="P:MB.WinEIDrive.Excel.ExcelFont.Weight"/>
        </member>
        <member name="F:MB.WinEIDrive.Excel.ExcelFont.NormalWeight">
            <summary>
            Normal font weight.
            </summary>
            <seealso cref="P:MB.WinEIDrive.Excel.ExcelFont.Weight"/>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelFont.Italic">
            <summary>
            Gets or sets if the font is italic.
            </summary>
            <remarks>
            Default value of this property is <b>false</b>.
            </remarks>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelFont.Name">
            <summary>
            Gets or sets name of the font.
            </summary>
            <remarks>
            Default value for this property is "Arial".
            </remarks>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelFont.Size">
            <summary>
            Gets or sets font size.
            </summary>
            <remarks>
            <p>Unit is twip (1/20th of a point).</p>
            <p>Default value of this property is 200.</p>
            </remarks>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelFont.Strikeout">
            <summary>
            Gets or sets if the font is struck out.
            </summary>
            <remarks>
            Default value of this property is <b>false</b>.
            </remarks>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelFont.Weight">
            <summary>
            Gets or sets font weight (font boldness).
            </summary>
            <remarks>
            <p>Font weight is an integer value between <see cref="F:MB.WinEIDrive.Excel.ExcelFont.MinWeight">
            MinWeight</see> and <see cref="F:MB.WinEIDrive.Excel.ExcelFont.MaxWeight">MaxWeight</see>.</p>
            <p>If you want font to have standard boldness, set this property to
            <see cref="F:MB.WinEIDrive.Excel.ExcelFont.BoldWeight">BoldWeight</see>.</p>
            <p>Default value of this property is <see cref="F:MB.WinEIDrive.Excel.ExcelFont.NormalWeight">NormalWeight</see>.</p>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if font weight is out of allowed range.</exception>
        </member>
        <member name="T:MB.WinEIDrive.Excel.ExcelLite">
            <summary>
            Contains static licensing methods (ExcelLite Professional only) and diagnostic
            information about executing ExcelLite assembly.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.ExcelLite.FullVersion">
            <summary>
            ExcelLite assembly full version.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.ExcelLite.Title">
            <summary>
            ExcelLite assembly title.
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.Excel.ExcelRow">
            <summary>
            Excel row contains row options and cell range with row cells.
            </summary>
            <seealso cref="T:MB.WinEIDrive.Excel.ExcelColumn"/>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ExcelRow.Delete">
            <summary>
            Deletes this row from the worksheet.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ExcelRow.InsertCopy(System.Int32,MB.WinEIDrive.Excel.ExcelRow)">
            <summary>
            Inserts specified number of copied rows before the current row.
            </summary>
            <param name="rowCount">Number of rows to insert.</param>
            <param name="sourceRow">Source row to copy.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ExcelRow.InsertEmpty(System.Int32)">
            <summary>
            Inserts specified number of empty rows before the current row.
            </summary>
            <param name="rowCount">Number of rows to insert.</param>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelRow.AllocatedCells">
            <summary>
            Gets only currently allocated cells for this row.
            </summary>
            <remarks>
            <p>Use this collection if you are reading entire Excel file (you don't know exact position of
            cells with data). If writing values, using <see cref="P:MB.WinEIDrive.Excel.ExcelRow.Cells">Cells</see>
            property is recommended.</p>
            <p>This collection contains only allocated cells so it is faster as you avoid
            checking every single cell in a row. You still need to check if a specific cell contains
            any value (it can be empty).</p>
            </remarks>
            <example> Following code reads entire XLS file and displays all cells containing any data.
            Data types are also displayed.
            <code lang="Visual Basic">
            Dim ef As ExcelFile = New ExcelFile("..\TestWorkbook.xls")
            Dim sheet As ExcelWorksheet
            Dim row As ExcelRow
            Dim cell As ExcelCell
            
            For Each sheet In ef.Worksheets
            Console.WriteLine("--------- {0} ---------", sheet.Name)
            
            For Each row In sheet.Rows
            For Each cell In row.AllocatedCells
            If Not cell.Value Is Nothing Then
            Console.Write("{0}({1})", cell.Value, cell.Value.GetType().Name)
            End If
            
            Console.Write(vbTab)
            Next
            
            Console.WriteLine()
            Next
            Next
            </code>
            <code lang="C#">
            ExcelFile ef = new ExcelFile("..\\..\\TestWorkbook.xls");
            
            foreach(ExcelWorksheet sheet in ef.Worksheets)
            {
            Console.WriteLine("--------- {0} ---------", sheet.Name);
            
            foreach(ExcelRow row in sheet.Rows)
            {
            foreach(ExcelCell cell in row.AllocatedCells)
            {
            if(cell.Value != null)
            Console.Write("{0}({1})", cell.Value, cell.Value.GetType().Name);
            
            Console.Write("\t");
            }
            
            Console.WriteLine();
            }
            }
            </code>
            </example>
            <seealso cref="P:MB.WinEIDrive.Excel.ExcelRow.Cells"/>
            <seealso cref="T:MB.WinEIDrive.Excel.ExcelCell"/>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelRow.Cells">
            <summary>
            Gets cell range with row cells.
            </summary>
            <example> Look at following code for cell referencing examples:
            <code lang="Visual Basic">
            Dim ws As ExcelWorksheet = excelFile.Worksheets.ActiveWorksheet
            
            ws.Cells("B2").Value = "Cell B2."
            ws.Cells(6, 0).Value = "Cell in row 7 and column A."
            
            ws.Rows(2).Cells(0).Value = "Cell in row 3 and column A."
            ws.Rows("4").Cells("B").Value = "Cell in row 4 and column B."
            
            ws.Columns(2).Cells(4).Value = "Cell in column C and row 5."
            ws.Columns("AA").Cells("6").Value = "Cell in AA column and row 6."
            </code>
            <code lang="C#">
            ExcelWorksheet ws = excelFile.Worksheets.ActiveWorksheet;
            
            ws.Cells["B2"].Value = "Cell B2.";
            ws.Cells[6,0].Value = "Cell in row 7 and column A.";
            
            ws.Rows[2].Cells[0].Value = "Cell in row 3 and column A.";
            ws.Rows["4"].Cells["B"].Value = "Cell in row 4 and column B.";
            
            ws.Columns[2].Cells[4].Value = "Cell in column C and row 5.";
            ws.Columns["AA"].Cells["6"].Value = "Cell in AA column and row 6.";
            </code>
            </example>
            <seealso cref="P:MB.WinEIDrive.Excel.ExcelRow.AllocatedCells"/>
            <seealso cref="T:MB.WinEIDrive.Excel.ExcelCell"/>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelRow.Height">
            <summary>
            Gets or sets row height.
            </summary>
            <remarks>
            Unit is twip (1/20th of a point).
            </remarks>
        </member>
        <member name="T:MB.WinEIDrive.Excel.ExcelRowCollection">
            <summary>
            Collection of excel rows (<see cref="T:MB.WinEIDrive.Excel.ExcelRow">ExcelRow</see>).
            </summary>
            <seealso cref="T:MB.WinEIDrive.Excel.ExcelRow"/>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ExcelRowCollection.RowIndexToName(System.Int32)">
            <summary>
            Converts row index (0, 1, ...) to row name ("1", "2", ...).
            </summary>
            <param name="rowIndex">Row index.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ExcelRowCollection.RowNameToIndex(System.String)">
            <summary>
            Converts row name ("1", "2", ...) to row index (0, 1, ...).
            </summary>
            <param name="name">Row name.</param>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelRowCollection.Item(System.String)">
            <summary>
            Gets the row with the specified name.
            </summary>
            <param name="name">The name of the row.</param>
            <example> Look at following code for cell referencing examples:
            <code lang="Visual Basic">
            Dim ws As ExcelWorksheet = excelFile.Worksheets.ActiveWorksheet
            
            ws.Cells("B2").Value = "Cell B2."
            ws.Cells(6, 0).Value = "Cell in row 7 and column A."
            
            ws.Rows(2).Cells(0).Value = "Cell in row 3 and column A."
            ws.Rows("4").Cells("B").Value = "Cell in row 4 and column B."
            
            ws.Columns(2).Cells(4).Value = "Cell in column C and row 5."
            ws.Columns("AA").Cells("6").Value = "Cell in AA column and row 6."
            </code>
            <code lang="C#">
            ExcelWorksheet ws = excelFile.Worksheets.ActiveWorksheet;
            
            ws.Cells["B2"].Value = "Cell B2.";
            ws.Cells[6,0].Value = "Cell in row 7 and column A.";
            
            ws.Rows[2].Cells[0].Value = "Cell in row 3 and column A.";
            ws.Rows["4"].Cells["B"].Value = "Cell in row 4 and column B.";
            
            ws.Columns[2].Cells[4].Value = "Cell in column C and row 5.";
            ws.Columns["AA"].Cells["6"].Value = "Cell in AA column and row 6.";
            </code>
            </example>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelRowCollection.Item(System.Int32)">
            <overloads>Gets the row with the specified index or name.</overloads>
            <summary>
            Gets the row with the specified index.
            </summary>
            <param name="index">The zero-based index of the row.</param>
            <example> Look at following code for cell referencing examples:
            <code lang="Visual Basic">
            Dim ws As ExcelWorksheet = excelFile.Worksheets.ActiveWorksheet
            
            ws.Cells("B2").Value = "Cell B2."
            ws.Cells(6, 0).Value = "Cell in row 7 and column A."
            
            ws.Rows(2).Cells(0).Value = "Cell in row 3 and column A."
            ws.Rows("4").Cells("B").Value = "Cell in row 4 and column B."
            
            ws.Columns(2).Cells(4).Value = "Cell in column C and row 5."
            ws.Columns("AA").Cells("6").Value = "Cell in AA column and row 6."
            </code>
            <code lang="C#">
            ExcelWorksheet ws = excelFile.Worksheets.ActiveWorksheet;
            
            ws.Cells["B2"].Value = "Cell B2.";
            ws.Cells[6,0].Value = "Cell in row 7 and column A.";
            
            ws.Rows[2].Cells[0].Value = "Cell in row 3 and column A.";
            ws.Rows["4"].Cells["B"].Value = "Cell in row 4 and column B.";
            
            ws.Columns[2].Cells[4].Value = "Cell in column C and row 5.";
            ws.Columns["AA"].Cells["6"].Value = "Cell in AA column and row 6.";
            </code>
            </example>
        </member>
        <member name="T:MB.WinEIDrive.Excel.ExcelWorksheet">
            <summary>
            Excel worksheet is a table with additional properties, identified by a unique name.
            </summary>
            <remarks>
            <p>
            Worksheet in Microsoft Excel has limited size.
            Number of rows (<see cref="T:MB.WinEIDrive.Excel.ExcelRow">ExcelRow</see>) is limited
            to <see cref="F:MB.WinEIDrive.Excel.ExcelFile.MaxRows">ExcelFile.MaxRows</see>.
            Number of columns (<see cref="T:MB.WinEIDrive.Excel.ExcelColumn">ExcelColumn</see>) is limited
            to <see cref="F:MB.WinEIDrive.Excel.ExcelFile.MaxColumns">ExcelFile.MaxColumns</see>.
            A specific cell (<see cref="T:MB.WinEIDrive.Excel.ExcelCell">ExcelCell</see>) can be accessed either trough
            <see cref="P:MB.WinEIDrive.Excel.ExcelRow.Cells">ExcelRow.Cells</see>,
            <see cref="P:MB.WinEIDrive.Excel.ExcelColumn.Cells">ExcelColumn.Cells</see> or
            <see cref="P:MB.WinEIDrive.Excel.ExcelWorksheet.Cells">ExcelWorksheet.Cells</see> property.
            Whichever property used, there are two distinct methods of getting a cell reference; using <b>name</b>
            and using <b>index</b>. For example, full name of cell in top left corner of a worksheet is "A1". Translated
            to indexes, same cell would be 0,0 (zero row and zero column). If using
            <see cref="P:MB.WinEIDrive.Excel.ExcelRow.Cells">ExcelRow.Cells</see> or
            <see cref="P:MB.WinEIDrive.Excel.ExcelColumn.Cells">ExcelColumn.Cells</see> to access a
            specific cell, only partial name or partial index must be used, providing unknown column or row information.
            </p>
            </remarks>
            <example> Look at following code for cell referencing examples:
            <code lang="Visual Basic">
            Dim ws As ExcelWorksheet = excelFile.Worksheets.ActiveWorksheet
            
            ws.Cells("B2").Value = "Cell B2."
            ws.Cells(6, 0).Value = "Cell in row 7 and column A."
            
            ws.Rows(2).Cells(0).Value = "Cell in row 3 and column A."
            ws.Rows("4").Cells("B").Value = "Cell in row 4 and column B."
            
            ws.Columns(2).Cells(4).Value = "Cell in column C and row 5."
            ws.Columns("AA").Cells("6").Value = "Cell in AA column and row 6."
            </code>
            <code lang="C#">
            ExcelWorksheet ws = excelFile.Worksheets.ActiveWorksheet;
            
            ws.Cells["B2"].Value = "Cell B2.";
            ws.Cells[6,0].Value = "Cell in row 7 and column A.";
            
            ws.Rows[2].Cells[0].Value = "Cell in row 3 and column A.";
            ws.Rows["4"].Cells["B"].Value = "Cell in row 4 and column B.";
            
            ws.Columns[2].Cells[4].Value = "Cell in column C and row 5.";
            ws.Columns["AA"].Cells["6"].Value = "Cell in AA column and row 6.";
            </code>
            </example>
            <seealso cref="T:MB.WinEIDrive.Excel.ExcelRow"/>
            <seealso cref="T:MB.WinEIDrive.Excel.ExcelColumn"/>
            <seealso cref="T:MB.WinEIDrive.Excel.ExcelCell"/>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ExcelWorksheet.Delete">
            <summary>
            Deletes this worksheet from the workbook.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ExcelWorksheet.InsertCopy(System.String,MB.WinEIDrive.Excel.ExcelWorksheet)">
            <summary>
            Inserts a copy of an existing worksheet before the current worksheet.
            </summary>
            <param name="destinationWorksheetName">Name of the new worksheet.</param>
            <param name="sourceWorksheet">Source worksheet.</param>
            <returns>Newly created worksheet.</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ExcelWorksheet.InsertEmpty(System.String)">
            <summary>
            Inserts an empty worksheet before the current worksheet.
            </summary>
            <param name="worksheetName">Worksheet name.</param>
            <returns>Newly created worksheet.</returns>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelWorksheet.AutomaticPageBreakScalingFactor">
            <summary>
            Scaling factor for automatic page breaks.
            </summary>
            <remarks>
            <p>Unit is one percent. Value must be between 10 and 400.</p>
            <p>Default value for this property is 255.</p>
            <p>MS Excel inserts automatic page breaks depending on this scaling factor.
            Smaller it gets, bigger will be the distance between the two automatic page breaks.</p>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if value is out of 10 to 400 range.</exception>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelWorksheet.Cells">
            <summary>
            Gets <see cref="T:MB.WinEIDrive.Excel.CellRange">CellRange</see> with all the cells
            (<see cref="T:MB.WinEIDrive.Excel.ExcelCell">ExcelCell</see>)
            in the worksheet.
            </summary>
            <example> Look at following code for cell referencing examples:
            <code lang="Visual Basic">
            Dim ws As ExcelWorksheet = excelFile.Worksheets.ActiveWorksheet
            
            ws.Cells("B2").Value = "Cell B2."
            ws.Cells(6, 0).Value = "Cell in row 7 and column A."
            
            ws.Rows(2).Cells(0).Value = "Cell in row 3 and column A."
            ws.Rows("4").Cells("B").Value = "Cell in row 4 and column B."
            
            ws.Columns(2).Cells(4).Value = "Cell in column C and row 5."
            ws.Columns("AA").Cells("6").Value = "Cell in AA column and row 6."
            </code>
            <code lang="C#">
            ExcelWorksheet ws = excelFile.Worksheets.ActiveWorksheet;
            
            ws.Cells["B2"].Value = "Cell B2.";
            ws.Cells[6,0].Value = "Cell in row 7 and column A.";
            
            ws.Rows[2].Cells[0].Value = "Cell in row 3 and column A.";
            ws.Rows["4"].Cells["B"].Value = "Cell in row 4 and column B.";
            
            ws.Columns[2].Cells[4].Value = "Cell in column C and row 5.";
            ws.Columns["AA"].Cells["6"].Value = "Cell in AA column and row 6.";
            </code>
            </example>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelWorksheet.Columns">
            <summary>
            Gets collection of all columns (<see cref="T:MB.WinEIDrive.Excel.ExcelColumn">ExcelColumn</see>) in the worksheet.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelWorksheet.DefaultColumnWidth">
            <summary>
            Gets or sets default column width.
            </summary>
            <remarks>
            Unit is 1/256th of the width of the zero character in default font. This value is used as width for columns
            which don't have <see cref="P:MB.WinEIDrive.Excel.ExcelColumn.Width">ExcelColumn.Width</see> property explicitly set.
            </remarks>
            <seealso cref="P:MB.WinEIDrive.Excel.ExcelColumn.Width">ExcelColumn.Width</seealso>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelWorksheet.FirstVisibleColumn">
            <summary>
            Index of the first visible column in the worksheet.
            </summary>
            <remarks>
            Default value for this property is 0.
            </remarks>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelWorksheet.FirstVisibleRow">
            <summary>
            Index of the first visible row in the worksheet.
            </summary>
            <remarks>
            Default value for this property is 0.
            </remarks>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelWorksheet.HorizontalPageBreaks">
            <summary>
            Gets collection of all horizontal page breaks
            (<see cref="T:MB.WinEIDrive.Excel.HorizontalPageBreak">HorizontalPageBreak</see>) in the worksheet.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelWorksheet.Name">
            <summary>
            Gets or sets worksheet name.
            </summary>
            <remarks>
            If not unique (worksheet with that name already exists in
            <see cref="P:MB.WinEIDrive.Excel.ExcelFile.Worksheets">ExcelFile.Worksheets</see> collection) exception is thrown.
            </remarks>
            <exception cref="T:System.ArgumentException">Thrown if worksheet name is not unique.</exception>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelWorksheet.NamedRanges">
            <summary>
            Gets <seealso cref="T:MB.WinEIDrive.Excel.NamedRangeCollection">NamedRangeCollection</seealso>
            containing descriptive names which are used to represent cells, ranges of cells,
            formulas, or constant values.
            </summary>
            <remarks>
            You can use the labels of columns and rows on a worksheet to refer to the cells within
            those columns and rows. Or you can create descriptive names to represent cells, ranges of cells,
            formulas, or constant values. Labels can be used in formulas that refer to data on the same
            worksheet; if you want to represent a range on another worksheet, use a name.
            You can also create 3-D names that represent the same cell or range of cells across multiple worksheets.
            </remarks>
            <example>Following code demonstrates how to use formulas and named ranges. It shows next features:
            cell references (both absolute and relative), unary and binary operators, constand operands (integer and floating point),
            functions and named cell ranges.
            <code lang="Visual Basic">
            ws.Cells("A1").Value = 5
            ws.Cells("A2").Value = 6
            ws.Cells("A3").Value = 10
            
            ws.Cells("C1").Formula = "=A1+A2"
            ws.Cells("C2").Formula = "=$A$1-A3"
            ws.Cells("C3").Formula = "=COUNT(A1:A3)"
            ws.Cells("C4").Formula = "=AVERAGE($A$1:$A$3)"
            ws.Cells("C5").Formula = "=SUM(A1:A3,2,3)"
            ws.Cells("C7").Formula = "= 123 - (-(-(23.5)))"
            
            ws.NamedRanges.Add("DataRange", ws.Cells.GetSubrange("A1", "A3"))
            ws.Cells("C8").Formula = "=MAX(DataRange)"
            
            Dim cr As CellRange = ws.Cells.GetSubrange("B9","C10")
            cr.Merged = True
            cr.Formula = "=A1*25"
            </code>
            <code lang="C#">
            ws.Cells["A1"].Value = 5;
            ws.Cells["A2"].Value = 6;
            ws.Cells["A3"].Value = 10;
            
            ws.Cells["C1"].Formula = "=A1+A2";
            ws.Cells["C2"].Formula = "=$A$1-A3";
            ws.Cells["C3"].Formula = "=COUNT(A1:A3)";
            ws.Cells["C4"].Formula = "=AVERAGE($A$1:$A$3)";
            ws.Cells["C5"].Formula = "=SUM(A1:A3,2,3)";
            ws.Cells["C7"].Formula = "= 123 - (-(-(23.5)))";
            
            ws.NamedRanges.Add("DataRange", ws.Cells.GetSubrange("A1", "A3"));
            ws.Cells["C8"].Formula = "=MAX(DataRange)";
            
            CellRange cr = ws.Cells.GetSubrange("B9", "C10");
            cr.Merged = true;
            cr.Formula = "=A1*25";
            </code>
            </example>
            <seealso cref="P:MB.WinEIDrive.Excel.ExcelCell.Formula">ExcelCell.Formula</seealso>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelWorksheet.OutlineColumnButtonsRight">
            <summary>
            Gets or sets whether outline column buttons are displayed on the right side of groups.
            </summary>
            <remarks>
            This property is simply written to Excel file and has no effect on behavior of this library.
            For more information on worksheet protection, consult Microsoft Excel documentation.
            </remarks>
            <example> Following code creates two horizontal groups and one vertical group. Horizontal groups have
            outline button above (default is below), while vertical group is collapsed.
            <code lang="Visual Basic">
            Sub GroupingSample(ByVal ws As ExcelWorksheet)
            ws.Cells(0, 0).Value = "Grouping and outline example:"
            
            <font color="Green">' Vertical grouping.</font>
            ws.Cells(2, 0).Value = "GroupA Start"
            ws.Rows(2).OutlineLevel = 1
            ws.Cells(3, 0).Value = "A"
            ws.Rows(3).OutlineLevel = 1
            ws.Cells(4, 1).Value = "GroupB Start"
            ws.Rows(4).OutlineLevel = 2
            ws.Cells(5, 1).Value = "B"
            ws.Rows(5).OutlineLevel = 2
            ws.Cells(6, 1).Value = "GroupB End"
            ws.Rows(6).OutlineLevel = 2
            ws.Cells(7, 0).Value = "GroupA End"
            ws.Rows(7).OutlineLevel = 1
            <font color="Green">' Put outline row buttons above groups.</font>
            ws.OutlineRowButtonsBelow = False
            
            <font color="Green">' Horizontal grouping (collapsed).</font>
            ws.Cells("E2").Value = "Gr.C Start"
            ws.Columns("E").OutlineLevel = 1
            ws.Columns("E").Collapsed = True
            ws.Cells("F2").Value = "C"
            ws.Columns("F").OutlineLevel = 1
            ws.Columns("F").Collapsed = True
            ws.Cells("G2").Value = "Gr.C End"
            ws.Columns("G").OutlineLevel = 1
            ws.Columns("G").Collapsed = True
            End Sub
            </code>
            <code lang="C#">
            static void GroupingSample(ExcelWorksheet ws)
            {
            ws.Cells[0,0].Value = "Grouping and outline example:";
            
            <font color="Green">// Vertical grouping.</font>
            ws.Cells[2,0].Value = "GroupA Start";
            ws.Rows[2].OutlineLevel = 1;
            ws.Cells[3,0].Value = "A";
            ws.Rows[3].OutlineLevel = 1;
            ws.Cells[4,1].Value = "GroupB Start";
            ws.Rows[4].OutlineLevel = 2;
            ws.Cells[5,1].Value = "B";
            ws.Rows[5].OutlineLevel = 2;
            ws.Cells[6,1].Value = "GroupB End";
            ws.Rows[6].OutlineLevel = 2;
            ws.Cells[7,0].Value = "GroupA End";
            ws.Rows[7].OutlineLevel = 1;
            <font color="Green">// Put outline row buttons above groups.</font>
            ws.OutlineRowButtonsBelow = false;
            
            <font color="Green">// Horizontal grouping (collapsed).</font>
            ws.Cells["E2"].Value = "Gr.C Start";
            ws.Columns["E"].OutlineLevel = 1;
            ws.Columns["E"].Collapsed = true;
            ws.Cells["F2"].Value = "C";
            ws.Columns["F"].OutlineLevel = 1;
            ws.Columns["F"].Collapsed = true;
            ws.Cells["G2"].Value = "Gr.C End";
            ws.Columns["G"].OutlineLevel = 1;
            ws.Columns["G"].Collapsed = true;
            }
            </code>
            </example>
            <seealso cref="P:MB.WinEIDrive.Excel.ExcelWorksheet.OutlineRowButtonsBelow">ExcelWorksheet.OutlineRowButtonsBelow</seealso>
            <seealso cref="P:MB.WinEIDrive.Excel.ExcelColumnRowBase.Collapsed"/>
            <seealso cref="P:MB.WinEIDrive.Excel.ExcelColumnRowBase.OutlineLevel"/>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelWorksheet.OutlineRowButtonsBelow">
            <summary>
            Gets or sets whether outline row buttons are displayed below groups.
            </summary>
            <remarks>
            This property is simply written to Excel file and has no effect on behavior of this library.
            For more information on worksheet protection, consult Microsoft Excel documentation.
            </remarks>
            <example> Following code creates two horizontal groups and one vertical group. Horizontal groups have
            outline button above (default is below), while vertical group is collapsed.
            <code lang="Visual Basic">
            Sub GroupingSample(ByVal ws As ExcelWorksheet)
            ws.Cells(0, 0).Value = "Grouping and outline example:"
            
            <font color="Green">' Vertical grouping.</font>
            ws.Cells(2, 0).Value = "GroupA Start"
            ws.Rows(2).OutlineLevel = 1
            ws.Cells(3, 0).Value = "A"
            ws.Rows(3).OutlineLevel = 1
            ws.Cells(4, 1).Value = "GroupB Start"
            ws.Rows(4).OutlineLevel = 2
            ws.Cells(5, 1).Value = "B"
            ws.Rows(5).OutlineLevel = 2
            ws.Cells(6, 1).Value = "GroupB End"
            ws.Rows(6).OutlineLevel = 2
            ws.Cells(7, 0).Value = "GroupA End"
            ws.Rows(7).OutlineLevel = 1
            <font color="Green">' Put outline row buttons above groups.</font>
            ws.OutlineRowButtonsBelow = False
            
            <font color="Green">' Horizontal grouping (collapsed).</font>
            ws.Cells("E2").Value = "Gr.C Start"
            ws.Columns("E").OutlineLevel = 1
            ws.Columns("E").Collapsed = True
            ws.Cells("F2").Value = "C"
            ws.Columns("F").OutlineLevel = 1
            ws.Columns("F").Collapsed = True
            ws.Cells("G2").Value = "Gr.C End"
            ws.Columns("G").OutlineLevel = 1
            ws.Columns("G").Collapsed = True
            End Sub
            </code>
            <code lang="C#">
            static void GroupingSample(ExcelWorksheet ws)
            {
            ws.Cells[0,0].Value = "Grouping and outline example:";
            
            <font color="Green">// Vertical grouping.</font>
            ws.Cells[2,0].Value = "GroupA Start";
            ws.Rows[2].OutlineLevel = 1;
            ws.Cells[3,0].Value = "A";
            ws.Rows[3].OutlineLevel = 1;
            ws.Cells[4,1].Value = "GroupB Start";
            ws.Rows[4].OutlineLevel = 2;
            ws.Cells[5,1].Value = "B";
            ws.Rows[5].OutlineLevel = 2;
            ws.Cells[6,1].Value = "GroupB End";
            ws.Rows[6].OutlineLevel = 2;
            ws.Cells[7,0].Value = "GroupA End";
            ws.Rows[7].OutlineLevel = 1;
            <font color="Green">// Put outline row buttons above groups.</font>
            ws.OutlineRowButtonsBelow = false;
            
            <font color="Green">// Horizontal grouping (collapsed).</font>
            ws.Cells["E2"].Value = "Gr.C Start";
            ws.Columns["E"].OutlineLevel = 1;
            ws.Columns["E"].Collapsed = true;
            ws.Cells["F2"].Value = "C";
            ws.Columns["F"].OutlineLevel = 1;
            ws.Columns["F"].Collapsed = true;
            ws.Cells["G2"].Value = "Gr.C End";
            ws.Columns["G"].OutlineLevel = 1;
            ws.Columns["G"].Collapsed = true;
            }
            </code>
            </example>
            <seealso cref="P:MB.WinEIDrive.Excel.ExcelWorksheet.OutlineColumnButtonsRight">ExcelWorksheet.OutlineColumnButtonsRight</seealso>
            <seealso cref="P:MB.WinEIDrive.Excel.ExcelColumnRowBase.Collapsed"/>
            <seealso cref="P:MB.WinEIDrive.Excel.ExcelColumnRowBase.OutlineLevel"/>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelWorksheet.PageBreakViewZoom">
            <summary>
            Magnification factor in page break view.
            </summary>
            <remarks>
            <p>Unit is one percent. Value must be between 10 and 400.</p>
            <p>Default value for this property is 60.</p>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if value is out of 10 to 400 range.</exception>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelWorksheet.Protected">
            <summary>
            Gets or sets the worksheet protection flag.
            </summary>
            <remarks>
            This property is simply written to Excel file and has no effect on the behavior of this library.
            For more information on worksheet protection, consult Microsoft Excel documentation.
            </remarks>
            <seealso cref="P:MB.WinEIDrive.Excel.ExcelFile.Protected">ExcelFile.Protected</seealso>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelWorksheet.Rows">
            <summary>
            Gets collection of all rows (<see cref="T:MB.WinEIDrive.Excel.ExcelRow">ExcelRow</see>) in the worksheet.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelWorksheet.ShowColumnsFromRightToLeft">
            <summary>
            If true, MS Excel shows columns from right to left.
            </summary>
            <remarks>
            Default value for this property is <b>false</b>.
            </remarks>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelWorksheet.ShowFormulas">
            <summary>
            If true, MS Excel shows formulas. Otherwise, formula results are shown.
            </summary>
            <remarks>
            Default value for this property is <b>false</b>.
            </remarks>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelWorksheet.ShowGridLines">
            <summary>
            If true, MS Excel shows grid lines.
            </summary>
            <remarks>
            Default value for this property is <b>true</b>.
            </remarks>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelWorksheet.ShowInPageBreakPreview">
            <summary>
            If true, MS Excel shows worksheet in page break preview. Otherwise, normal view is used.
            </summary>
            <remarks>
            Default value for this property is <b>false</b>.
            </remarks>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelWorksheet.ShowOutlineSymbols">
            <summary>
            If true, MS Excel shows outline symbols.
            </summary>
            <remarks>
            Default value for this property is <b>true</b>.
            </remarks>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelWorksheet.ShowSheetHeaders">
            <summary>
            If true, MS Excel shows row and column headers.
            </summary>
            <remarks>
            Default value for this property is <b>true</b>.
            </remarks>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelWorksheet.ShowZeroValues">
            <summary>
            If true, MS Excel shows zero values. Otherwise, zero values are shown as empty cells.
            </summary>
            <remarks>
            Default value for this property is <b>true</b>.
            </remarks>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelWorksheet.VerticalPageBreaks">
            <summary>
            Gets collection of all vertical page breaks
            (<see cref="T:MB.WinEIDrive.Excel.VerticalPageBreak">VerticalPageBreak</see>) in the worksheet.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelWorksheet.Zoom">
            <summary>
            Magnification factor in normal view.
            </summary>
            <remarks>
            <p>Unit is one percent. Value must be between 10 and 400.</p>
            <p>Default value for this property is 100.</p>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if value is out of 10 to 400 range.</exception>
        </member>
        <member name="T:MB.WinEIDrive.Excel.ExcelWorksheetCollection">
            <summary>
            Collection of worksheets (<see cref="T:MB.WinEIDrive.Excel.ExcelWorksheet">ExcelWorksheet</see>).
            </summary>
            <seealso cref="T:MB.WinEIDrive.Excel.ExcelWorksheet"/>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ExcelWorksheetCollection.Add(System.String)">
            <summary>
            Adds an empty worksheet to the end of the collection.
            </summary>
            <param name="worksheetName">Worksheet name.</param>
            <returns>Newly created worksheet.</returns>
            <remarks>
            If this is the first worksheet added to the collection the
            <see cref="P:MB.WinEIDrive.Excel.ExcelWorksheetCollection.ActiveWorksheet">ActiveWorksheet</see> is set to this worksheet.
            </remarks>
            <exception cref="T:System.ArgumentException">Thrown if worksheet name is not unique.</exception>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ExcelWorksheetCollection.AddCopy(System.String,MB.WinEIDrive.Excel.ExcelWorksheet)">
            <summary>
            Adds a copy of an existing worksheet to the end of the collection.
            </summary>
            <param name="destinationWorksheetName">Name of new worksheet.</param>
            <param name="sourceWorksheet">Source worksheet.</param>
            <returns>Newly created worksheet.</returns>
            <remarks>
            If this is the first worksheet added to the collection the
            <see cref="P:MB.WinEIDrive.Excel.ExcelWorksheetCollection.ActiveWorksheet">ActiveWorksheet</see> is set to this worksheet.
            </remarks>
            <exception cref="T:System.ArgumentException">Thrown if worksheet name is not unique.</exception>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ExcelWorksheetCollection.GetEnumerator">
            <summary>
            Returns an enumerator for the <see cref="T:MB.WinEIDrive.Excel.ExcelWorksheetCollection">
            ExcelWorksheetCollection</see>.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelWorksheetCollection.ActiveWorksheet">
            <summary>
            Gets or sets active worksheet.
            </summary>
            <remarks>
            Active worksheet is the one selected when file is opened with Microsoft Excel. By default active worksheet
            is the first one added with <see cref="M:MB.WinEIDrive.Excel.ExcelWorksheetCollection.Add(System.String)">Add</see> method.
            </remarks>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelWorksheetCollection.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:MB.WinEIDrive.Excel.ExcelWorksheetCollection">
            ExcelWorksheetCollection</see>.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelWorksheetCollection.Item(System.String)">
            <summary>
            Gets the worksheet with the specified name.
            </summary>
            <param name="name">The name of the worksheet.</param>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelWorksheetCollection.Item(System.Int32)">
            <overloads>Gets the worksheet with the specified index or name.</overloads>
            <summary>
            Gets the worksheet with the specified index.
            </summary>
            <param name="index">The zero-based index of the worksheet.</param>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelWorksheetCollection.SheetIndexes">
            <summary>
            Gets the sheet indexes.
            </summary>
            <value>The sheet indexes.</value>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExcelWorksheetCollection.SheetNames">
            <summary>
            Gets the sheet names.
            </summary>
            <value>The sheet names.</value>
        </member>
        <member name="T:MB.WinEIDrive.Excel.ExternsheetRecord">
            <summary>
            Externsheet record for holding information REF' structures
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ExternsheetRecord.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.ExternsheetRecord"/> class.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.ExternsheetRecord.#ctor(System.Int32,System.IO.BinaryReader,MB.WinEIDrive.Excel.AbsXLSRec)">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.ExternsheetRecord"/> class.
            </summary>
            <param name="bodyLength">Length of the body.</param>
            <param name="br">The binary reader to read from.</param>
            <param name="previousRecord">The previous record.</param>
        </member>
        <member name="P:MB.WinEIDrive.Excel.ExternsheetRecord.SheetIndexes">
            <summary>
            Gets the sheet indexes.
            </summary>
            <value>The sheet indexes.</value>
        </member>
        <member name="T:MB.WinEIDrive.Excel.FillPatternStyle">
            <summary>
            Fill pattern styles used for
            <see cref="P:MB.WinEIDrive.Excel.ExcelFillPattern.PatternStyle">ExcelFillPattern.PatternStyle</see>.
            </summary>
            <remarks>
            <p>To see names of Microsoft Excel patterns, start Microsoft Excel and go to "Format" menu &gt; "Cells..." submenu &gt;
            "Patterns" tab &gt; "Pattern" drop-down. When hovering over a pattern, Microsoft Excel name is displayed in tooltip
            text.</p>
            <p><b>None</b> fill pattern uses no colors.</p>
            <p><b>Solid</b> fill pattern uses <see cref="P:MB.WinEIDrive.Excel.ExcelFillPattern.PatternForegroundColor">
            ExcelFillPattern.PatternForegroundColor</see>.</p>
            <p>All other paterns use both <see cref="P:MB.WinEIDrive.Excel.ExcelFillPattern.PatternForegroundColor">
            ExcelFillPattern.PatternForegroundColor</see> and
            <see cref="P:MB.WinEIDrive.Excel.ExcelFillPattern.PatternBackgroundColor">ExcelFillPattern.PatternBackgroundColor</see></p>
            </remarks>
            <seealso cref="P:MB.WinEIDrive.Excel.ExcelFillPattern.PatternStyle">ExcelFillPattern.PatternStyle</seealso>
            <seealso cref="P:MB.WinEIDrive.Excel.ExcelFillPattern.PatternForegroundColor">ExcelFillPattern.PatternForegroundColor</seealso>
            <seealso cref="P:MB.WinEIDrive.Excel.ExcelFillPattern.PatternBackgroundColor">ExcelFillPattern.PatternBackgroundColor</seealso>
        </member>
        <member name="T:MB.WinEIDrive.Excel.FormulaFunctionInfo">
            <summary>
            Hold information about function( name, code, expected arguments count. )
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.FormulaFunctionInfo.VariableArgumentAmountMark">
            <summary>
            Is used to the specify for appropriate functins the variable count of arguments
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.FormulaFunctionInfo.#ctor(System.UInt16,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.FormulaFunctionInfo"/> class.
            </summary>
            <param name="code">The function code.</param>
            <param name="name">The function name.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.FormulaFunctionInfo.#ctor(System.UInt16,System.String,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.FormulaFunctionInfo"/> class.
            </summary>
            <param name="code">The function code.</param>
            <param name="name">The function name.</param>
            <param name="argumentsCount">The function's arguments count.</param>
        </member>
        <member name="F:MB.WinEIDrive.Excel.FormulaFunctionInfo.argumentsCount">
            <summary>
            Arguments count value, by default it is initilized with not fixed( variable ) argument count mark.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.FormulaFunctionInfo.ArgumentsCount">
            <summary>
            Arguments count value, by default it is initilized with not fixed( variable ) argument count mark.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.FormulaFunctionInfo.Code">
            <summary>
            Gets function code.
            </summary>
            <value>The function code.</value>
        </member>
        <member name="P:MB.WinEIDrive.Excel.FormulaFunctionInfo.IsFixedArgumentCount">
            <summary>
            Gets a value indicating whether function has fixed argument count.
            </summary>
            <value>
            <c>true</c> if this function has fixed argument count; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:MB.WinEIDrive.Excel.FormulaFunctionInfo.Name">
            <summary>
            Gets function name.
            </summary>
            <value>Function name.</value>
        </member>
        <member name="T:MB.WinEIDrive.Excel.FormulaFunctionsTable">
            <summary>
            Hold information about all supported functions.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.FormulaFunctionsTable.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.FormulaFunctionsTable"/> class.
            Constructor is private to allow only creation of FormulaFunctionsTable instances only once.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.FormulaFunctionsTable.IsFunction(System.String)">
            <summary>
            Determines whether the specified name is function.
            </summary>
            <param name="name">The name.</param>
            <returns>
            <c>true</c> if the specified name is function; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="P:MB.WinEIDrive.Excel.FormulaFunctionsTable.Instance">
            <summary>
            Gets the static FormulaFunctionsTable instance. Used to be shared between FormulaFunctionsTable' users.
            </summary>
            <value>The singleton FormulaFunctionTable instance.</value>
        </member>
        <member name="P:MB.WinEIDrive.Excel.FormulaFunctionsTable.Item(System.String)">
            <summary>
            Gets the <see cref="T:MB.WinEIDrive.Excel.FormulaFunctionInfo"/> at the specified index.
            </summary>
            <value><see cref="T:MB.WinEIDrive.Excel.FormulaFunctionInfo"/> instance</value>
        </member>
        <member name="P:MB.WinEIDrive.Excel.FormulaFunctionsTable.Item(System.UInt16)">
            <summary>
            Gets the <see cref="T:MB.WinEIDrive.Excel.FormulaFunctionInfo"/> at the specified index.
            </summary>
            <value><see cref="T:MB.WinEIDrive.Excel.FormulaFunctionInfo"/> instance</value>
        </member>
        <member name="P:MB.WinEIDrive.Excel.FormulaFunctionsTable.Names">
            <summary>
            Gets the names of predefined Excel functions.
            </summary>
            <value>The names of prdefined Excel function.</value>
        </member>
        <member name="T:MB.WinEIDrive.Excel.FormulaTokenClass">
            <summary>
            The set of predefined formula token classes
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.Excel.FormulaTokenCode">
            <summary>
            The set of predefined formula token codes
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.FormulaTokensFactory.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.FormulaTokensFactory"/> class.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.FormulaTokensFactory.CreateFrom(System.Byte[],System.Int32)">
            <summary>
            Creates formula token from rpn bytes and the code read from that bytes.
            </summary>
            <param name="rpnBytes">The RPN bytes.</param>
            <param name="startIndex">The start index to read code from the RPN bytes.</param>
            <returns>created formula token</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.FormulaTokensFactory.CreateFromCode(MB.WinEIDrive.Excel.FormulaTokenCode)">
            <summary>
            Creates formula token from code.
            </summary>
            <param name="tokenCode">The token code.</param>
            <returns>created formula token</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.FormulaTokensFactory.CreateFromCode(System.Byte)">
            <summary>
            Creates formula token from byte code.
            </summary>
            <param name="code">The byte code.</param>
            <returns>created formula token</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.FormulaTokensFactory.CreateFunctionFromName(System.String,MB.WinEIDrive.Excel.FormulaTokenClass,System.Byte)">
            <summary>
            Creates formula token form the name of the function.
            </summary>
            <param name="name">The name of the function.</param>
            <param name="tokenClass">The token class.</param>
            <param name="argumentsCount">The arguments count for the function.</param>
            <returns>created formula token</returns>
        </member>
        <member name="T:MB.WinEIDrive.Excel.FormulaTokenType">
            <summary>
            The set of predefined formula token types
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.Excel.FormulaTokenTypeEx">
            <summary>
            It is wrapper arodung FormulaTokenType enum to provide high-level bool methods
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.FormulaTokenTypeEx.#ctor(MB.WinEIDrive.Excel.FormulaTokenType)">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.FormulaTokenTypeEx"/> class.
            </summary>
            <param name="type">The type.</param>
        </member>
        <member name="P:MB.WinEIDrive.Excel.FormulaTokenTypeEx.IsBinary">
            <summary>
            Gets a value indicating whether this instance is binary.
            </summary>
            <value><c>true</c> if this instance is binary; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:MB.WinEIDrive.Excel.FormulaTokenTypeEx.IsControl">
            <summary>
            Gets a value indicating whether this instance is control.
            </summary>
            <value>
            <c>true</c> if this instance is control; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:MB.WinEIDrive.Excel.FormulaTokenTypeEx.IsFunction">
            <summary>
            Gets a value indicating whether this instance is function.
            </summary>
            <value>
            <c>true</c> if this instance is function; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:MB.WinEIDrive.Excel.FormulaTokenTypeEx.IsOperand">
            <summary>
            Gets a value indicating whether this instance is operand.
            </summary>
            <value>
            <c>true</c> if this instance is operand; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:MB.WinEIDrive.Excel.FormulaTokenTypeEx.IsUnary">
            <summary>
            Gets a value indicating whether this instance is unary.
            </summary>
            <value><c>true</c> if this instance is unary; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:MB.WinEIDrive.Excel.FormulaTokenTypeEx.Type">
            <summary>
            Gets the formula token type.
            </summary>
            <value>The formula token type.</value>
        </member>
        <member name="T:MB.WinEIDrive.Excel.FunctionFormulaToken">
            <summary>
            Formula token for holding function.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.FunctionFormulaToken.#ctor(MB.WinEIDrive.Excel.FormulaTokenCode)">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.FunctionFormulaToken"/> class.
            </summary>
            <param name="code">The code.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.FunctionFormulaToken.ConvertToBytes">
            <summary>
            Convert formula token to array of byte representation.
            </summary>
            <returns>formula token' array of byte representation</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.FunctionFormulaToken.DelayInitialize(System.Object[])">
            <summary>
            Make custom delay initialize.
            </summary>
            <param name="data">The data for initialization which is unique for each formula token.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.FunctionFormulaToken.Read(System.Byte[],System.Int32)">
            <summary>
            Initialize formula token by reading input data from array of bytes
            </summary>
            <param name="rpnBytes">input data, array of bytes</param>
            <param name="startIndex">start position for array of bytes to read from</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.FunctionFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="T:MB.WinEIDrive.Excel.FunctionVarFormulaToken">
            <summary>
            Formula token for holding function with variable arguments count.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.FunctionVarFormulaToken.#ctor(MB.WinEIDrive.Excel.FormulaTokenCode)">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.FunctionVarFormulaToken"/> class.
            </summary>
            <param name="code">The code.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.FunctionVarFormulaToken.ConvertToBytes">
            <summary>
            Convert formula token to array of byte representation.
            </summary>
            <returns>formula token' array of byte representation</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.FunctionVarFormulaToken.DelayInitialize(System.Object[])">
            <summary>
            Make custom delay initialize.
            </summary>
            <param name="data">The data for initialization which is unique for each formula token.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.FunctionVarFormulaToken.Read(System.Byte[],System.Int32)">
            <summary>
            Initialize formula token by reading input data from array of bytes
            </summary>
            <param name="rpnBytes">input data, array of bytes</param>
            <param name="startIndex">start position for array of bytes to read from</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.FunctionVarFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="T:MB.WinEIDrive.Excel.HorizontalAlignmentStyle">
            <summary>
            Horizontal alignment styles used for <see cref="P:MB.WinEIDrive.Excel.CellStyle.HorizontalAlignment">
            CellStyle.HorizontalAlignment</see>.
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.Excel.HorizontalPageBreak">
            <summary>
            Specifies a horizontal position where the new page begins when the worksheet is printed.
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.Excel.PageBreak">
            <summary>
            Base class for all page breaks.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.HorizontalPageBreak.FirstColumn">
            <summary>
            Index of the first column of the new page.
            </summary>
            <remarks>
            Use 0 (first column) if you don't care.
            </remarks>
        </member>
        <member name="P:MB.WinEIDrive.Excel.HorizontalPageBreak.LastColumn">
            <summary>
            Index of the last column of the new page.
            </summary>
            <remarks>
            Use 255 (last column) if you don't care.
            </remarks>
        </member>
        <member name="P:MB.WinEIDrive.Excel.HorizontalPageBreak.Row">
            <summary>
            Index of the first row of the new page.
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.Excel.HorizontalPageBreakCollection">
            <summary>
            Collection of horizontal page breaks (<see cref="T:MB.WinEIDrive.Excel.HorizontalPageBreak">HorizontalPageBreak</see>).
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.Excel.PageBreakCollection">
            <summary>
            Base class for page break collections.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.PageBreakCollection.Clear">
            <summary>
            Removes all page breaks.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.PageBreakCollection.GetEnumerator">
            <summary>
            Returns an enumerator for the collection.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.PageBreakCollection.RemoveAt(System.Int32)">
            <summary>
            Removes the page break at the specified index.
            </summary>
            <param name="index">The zero-based index of the page break to remove.</param>
        </member>
        <member name="P:MB.WinEIDrive.Excel.PageBreakCollection.Count">
            <summary>
            Gets the number of page breaks contained in the collection.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.HorizontalPageBreakCollection.Add(System.Int32)">
            <overloads>Ads a new horizontal page break.</overloads>
            <summary>
            Ads a new horizontal page break above the specified row.
            </summary>
            <param name="row">The zero-based index of the row.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.HorizontalPageBreakCollection.Add(System.Int32,System.Int32,System.Int32)">
            <summary>
            Ads a new horizontal page break above the specified row and within specified columns.
            </summary>
            <param name="row">The zero-based index of the row.</param>
            <param name="firstColumn">The zero-based index of the first column.</param>
            <param name="lastColumn">The zero-based index of the last column.</param>
        </member>
        <member name="P:MB.WinEIDrive.Excel.HorizontalPageBreakCollection.Item(System.Int32)">
            <summary>
            Gets or sets the horizontal page break at the specified index.
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.Excel.IndividualBorder">
            <summary>
            Different borders that can be set on excel cell. Members of this enumeration can't be combined.
            </summary>
            <seealso cref="T:MB.WinEIDrive.Excel.MultipleBorders"/>
        </member>
        <member name="T:MB.WinEIDrive.Excel.IntFormulaToken">
            <summary>
            Formula token for holding integer.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.IntFormulaToken.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.IntFormulaToken"/> class.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.IntFormulaToken.ConvertToBytes">
            <summary>
            Convert formula token to bytes representation.
            </summary>
            <returns>bytes representation of the formula token</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.IntFormulaToken.DelayInitialize(System.Object[])">
            <summary>
            Make custom delay initialize.
            </summary>
            <param name="data">The data for initialization which is unique for each formula token.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.IntFormulaToken.Read(System.Byte[],System.Int32)">
            <summary>
            Initialize formula token by reading input data from array of bytes
            </summary>
            <param name="rpnBytes">input data, array of bytes</param>
            <param name="startIndex">start position for array of bytes to read from</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.IntFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="T:MB.WinEIDrive.Excel.LimitEventArgs">
            <summary>
            Event parameters used for the <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitNear">ExcelFile.LimitNear</see>
            and <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitReached">ExcelFile.LimitReached</see> events.
            </summary>
            <example> Following code demonstrates how to handle <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitNear">LimitNear</see>
            and <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitReached">LimitReached</see> events in <b>ExcelLite Free</b>.
            This sample disables warning worksheet in <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitNear">LimitNear</see> event
            handler and displays console messages in
            <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitReached">LimitReached</see> event handler.
            <code lang="Visual Basic">
            Sub Main()
            Dim ef As ExcelFile = New ExcelFile
            
            AddHandler ef.LimitNear, AddressOf ef_LimitNear
            AddHandler ef.LimitReached, AddressOf ef_LimitReached
            
            Dim ws As ExcelWorksheet = ef.Worksheets.Add("Sheet1")
            
            Dim i As Integer
            For i = 0 To 172 - 1 Step i + 1
            ws.Cells(i, 0).Value = i
            Next
            
            ef.SaveXls("Test.xls")
            End Sub
            
            Private Sub ef_LimitNear(ByVal sender As Object, ByVal e As LimitEventArgs)
            e.WriteWarningWorksheet = False
            End Sub
            
            Private Sub ef_LimitReached(ByVal sender As Object, ByVal e As LimitEventArgs)
            Select Case e.Operation
            Case LimitEventOperation.XlsReading
            Console.WriteLine("Data truncated while reading XLS file: " + e.FileName)
            
            Case LimitEventOperation.CsvReading
            Console.WriteLine("Data truncated while reading CSV file: " + e.FileName)
            
            Case LimitEventOperation.XlsWriting
            Console.WriteLine("Data truncated while writing XLS file: " + e.FileName)
            e.WriteWarningWorksheet = False
            
            Case LimitEventOperation.CsvWriting
            Console.WriteLine("Data truncated while writing CSV file: " + e.FileName)
            
            End Select
            End Sub
            </code>
            <code lang="C#">
            static void Main(string[] args)
            {
            ExcelFile ef = new ExcelFile();
            
            ef.LimitNear += new LimitEventHandler(ef_LimitNear);
            ef.LimitReached += new LimitEventHandler(ef_LimitReached);
            
            ExcelWorksheet ws = ef.Worksheets.Add("Sheet1");
            
            for(int i=0; i!=172; i++)
            ws.Cells[i, 0].Value = i;
            
            ef.SaveXls("Test.xls");
            }
            
            private static void ef_LimitNear(object sender, LimitEventArgs e)
            {
            e.WriteWarningWorksheet = false;
            }
            
            private static void ef_LimitReached(object sender, LimitEventArgs e)
            {
            switch(e.Operation)
            {
            case LimitEventOperation.XlsReading:
            Console.WriteLine("Data truncated while reading XLS file: " + e.FileName);
            break;
            
            case LimitEventOperation.CsvReading:
            Console.WriteLine("Data truncated while reading CSV file: " + e.FileName);
            break;
            
            case LimitEventOperation.XlsWriting:
            Console.WriteLine("Data truncated while writing XLS file: " + e.FileName);
            e.WriteWarningWorksheet = false;
            break;
            
            case LimitEventOperation.CsvWriting:
            Console.WriteLine("Data truncated while writing CSV file: " + e.FileName);
            break;
            }
            }
            </code>
            </example>
        </member>
        <member name="P:MB.WinEIDrive.Excel.LimitEventArgs.FileName">
            <summary>
            Gets the file name passed to the XLS / CSV file reading / writing method.
            </summary>
            <remarks>
            You can use this property to handle different files in a different way inside your event handlers.
            </remarks>
            <example> Following code demonstrates how to handle <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitNear">LimitNear</see>
            and <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitReached">LimitReached</see> events in <b>ExcelLite Free</b>.
            This sample disables warning worksheet in <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitNear">LimitNear</see> event
            handler and displays console messages in
            <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitReached">LimitReached</see> event handler.
            <code lang="Visual Basic">
            Sub Main()
            Dim ef As ExcelFile = New ExcelFile
            
            AddHandler ef.LimitNear, AddressOf ef_LimitNear
            AddHandler ef.LimitReached, AddressOf ef_LimitReached
            
            Dim ws As ExcelWorksheet = ef.Worksheets.Add("Sheet1")
            
            Dim i As Integer
            For i = 0 To 172 - 1 Step i + 1
            ws.Cells(i, 0).Value = i
            Next
            
            ef.SaveXls("Test.xls")
            End Sub
            
            Private Sub ef_LimitNear(ByVal sender As Object, ByVal e As LimitEventArgs)
            e.WriteWarningWorksheet = False
            End Sub
            
            Private Sub ef_LimitReached(ByVal sender As Object, ByVal e As LimitEventArgs)
            Select Case e.Operation
            Case LimitEventOperation.XlsReading
            Console.WriteLine("Data truncated while reading XLS file: " + e.FileName)
            
            Case LimitEventOperation.CsvReading
            Console.WriteLine("Data truncated while reading CSV file: " + e.FileName)
            
            Case LimitEventOperation.XlsWriting
            Console.WriteLine("Data truncated while writing XLS file: " + e.FileName)
            e.WriteWarningWorksheet = False
            
            Case LimitEventOperation.CsvWriting
            Console.WriteLine("Data truncated while writing CSV file: " + e.FileName)
            
            End Select
            End Sub
            </code>
            <code lang="C#">
            static void Main(string[] args)
            {
            ExcelFile ef = new ExcelFile();
            
            ef.LimitNear += new LimitEventHandler(ef_LimitNear);
            ef.LimitReached += new LimitEventHandler(ef_LimitReached);
            
            ExcelWorksheet ws = ef.Worksheets.Add("Sheet1");
            
            for(int i=0; i!=172; i++)
            ws.Cells[i, 0].Value = i;
            
            ef.SaveXls("Test.xls");
            }
            
            private static void ef_LimitNear(object sender, LimitEventArgs e)
            {
            e.WriteWarningWorksheet = false;
            }
            
            private static void ef_LimitReached(object sender, LimitEventArgs e)
            {
            switch(e.Operation)
            {
            case LimitEventOperation.XlsReading:
            Console.WriteLine("Data truncated while reading XLS file: " + e.FileName);
            break;
            
            case LimitEventOperation.CsvReading:
            Console.WriteLine("Data truncated while reading CSV file: " + e.FileName);
            break;
            
            case LimitEventOperation.XlsWriting:
            Console.WriteLine("Data truncated while writing XLS file: " + e.FileName);
            e.WriteWarningWorksheet = false;
            break;
            
            case LimitEventOperation.CsvWriting:
            Console.WriteLine("Data truncated while writing CSV file: " + e.FileName);
            break;
            }
            }
            </code>
            </example>
        </member>
        <member name="P:MB.WinEIDrive.Excel.LimitEventArgs.MaxRowCount">
            <summary>
            Gets the maximum number of rows used.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.LimitEventArgs.Operation">
            <summary>
            Indicates which operation caused this event to fire.
            </summary>
            <remarks>
            You can use this property to handle XLS / CSV or reading / writing operations differently
            inside your event handlers.
            </remarks>
            <example> Following code demonstrates how to handle <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitNear">LimitNear</see>
            and <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitReached">LimitReached</see> events in <b>ExcelLite Free</b>.
            This sample disables warning worksheet in <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitNear">LimitNear</see> event
            handler and displays console messages in
            <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitReached">LimitReached</see> event handler.
            <code lang="Visual Basic">
            Sub Main()
            Dim ef As ExcelFile = New ExcelFile
            
            AddHandler ef.LimitNear, AddressOf ef_LimitNear
            AddHandler ef.LimitReached, AddressOf ef_LimitReached
            
            Dim ws As ExcelWorksheet = ef.Worksheets.Add("Sheet1")
            
            Dim i As Integer
            For i = 0 To 172 - 1 Step i + 1
            ws.Cells(i, 0).Value = i
            Next
            
            ef.SaveXls("Test.xls")
            End Sub
            
            Private Sub ef_LimitNear(ByVal sender As Object, ByVal e As LimitEventArgs)
            e.WriteWarningWorksheet = False
            End Sub
            
            Private Sub ef_LimitReached(ByVal sender As Object, ByVal e As LimitEventArgs)
            Select Case e.Operation
            Case LimitEventOperation.XlsReading
            Console.WriteLine("Data truncated while reading XLS file: " + e.FileName)
            
            Case LimitEventOperation.CsvReading
            Console.WriteLine("Data truncated while reading CSV file: " + e.FileName)
            
            Case LimitEventOperation.XlsWriting
            Console.WriteLine("Data truncated while writing XLS file: " + e.FileName)
            e.WriteWarningWorksheet = False
            
            Case LimitEventOperation.CsvWriting
            Console.WriteLine("Data truncated while writing CSV file: " + e.FileName)
            
            End Select
            End Sub
            </code>
            <code lang="C#">
            static void Main(string[] args)
            {
            ExcelFile ef = new ExcelFile();
            
            ef.LimitNear += new LimitEventHandler(ef_LimitNear);
            ef.LimitReached += new LimitEventHandler(ef_LimitReached);
            
            ExcelWorksheet ws = ef.Worksheets.Add("Sheet1");
            
            for(int i=0; i!=172; i++)
            ws.Cells[i, 0].Value = i;
            
            ef.SaveXls("Test.xls");
            }
            
            private static void ef_LimitNear(object sender, LimitEventArgs e)
            {
            e.WriteWarningWorksheet = false;
            }
            
            private static void ef_LimitReached(object sender, LimitEventArgs e)
            {
            switch(e.Operation)
            {
            case LimitEventOperation.XlsReading:
            Console.WriteLine("Data truncated while reading XLS file: " + e.FileName);
            break;
            
            case LimitEventOperation.CsvReading:
            Console.WriteLine("Data truncated while reading CSV file: " + e.FileName);
            break;
            
            case LimitEventOperation.XlsWriting:
            Console.WriteLine("Data truncated while writing XLS file: " + e.FileName);
            e.WriteWarningWorksheet = false;
            break;
            
            case LimitEventOperation.CsvWriting:
            Console.WriteLine("Data truncated while writing CSV file: " + e.FileName);
            break;
            }
            }
            </code>
            </example>
        </member>
        <member name="P:MB.WinEIDrive.Excel.LimitEventArgs.WorksheetCount">
            <summary>
            Gets the number of worksheets used.
            </summary>
            <remarks>
            <p>For CSV files, this is always 1 (as only
            <see cref="P:MB.WinEIDrive.Excel.ExcelWorksheetCollection.ActiveWorksheet">ActiveWorksheet</see> is used).</p>
            <p>When writing XLS files, warning worksheet is not counted.</p>
            </remarks>
        </member>
        <member name="P:MB.WinEIDrive.Excel.LimitEventArgs.WriteWarningWorksheet">
            <summary>
            Gets or sets whether the warning worksheet should be created when writing XLS file.
            </summary>
            <remarks>
            This property is ignored for CSV files and when reading XLS files.
            </remarks>
            <example> Following code demonstrates how to handle <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitNear">LimitNear</see>
            and <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitReached">LimitReached</see> events in <b>ExcelLite Free</b>.
            This sample disables warning worksheet in <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitNear">LimitNear</see> event
            handler and displays console messages in
            <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitReached">LimitReached</see> event handler.
            <code lang="Visual Basic">
            Sub Main()
            Dim ef As ExcelFile = New ExcelFile
            
            AddHandler ef.LimitNear, AddressOf ef_LimitNear
            AddHandler ef.LimitReached, AddressOf ef_LimitReached
            
            Dim ws As ExcelWorksheet = ef.Worksheets.Add("Sheet1")
            
            Dim i As Integer
            For i = 0 To 172 - 1 Step i + 1
            ws.Cells(i, 0).Value = i
            Next
            
            ef.SaveXls("Test.xls")
            End Sub
            
            Private Sub ef_LimitNear(ByVal sender As Object, ByVal e As LimitEventArgs)
            e.WriteWarningWorksheet = False
            End Sub
            
            Private Sub ef_LimitReached(ByVal sender As Object, ByVal e As LimitEventArgs)
            Select Case e.Operation
            Case LimitEventOperation.XlsReading
            Console.WriteLine("Data truncated while reading XLS file: " + e.FileName)
            
            Case LimitEventOperation.CsvReading
            Console.WriteLine("Data truncated while reading CSV file: " + e.FileName)
            
            Case LimitEventOperation.XlsWriting
            Console.WriteLine("Data truncated while writing XLS file: " + e.FileName)
            e.WriteWarningWorksheet = False
            
            Case LimitEventOperation.CsvWriting
            Console.WriteLine("Data truncated while writing CSV file: " + e.FileName)
            
            End Select
            End Sub
            </code>
            <code lang="C#">
            static void Main(string[] args)
            {
            ExcelFile ef = new ExcelFile();
            
            ef.LimitNear += new LimitEventHandler(ef_LimitNear);
            ef.LimitReached += new LimitEventHandler(ef_LimitReached);
            
            ExcelWorksheet ws = ef.Worksheets.Add("Sheet1");
            
            for(int i=0; i!=172; i++)
            ws.Cells[i, 0].Value = i;
            
            ef.SaveXls("Test.xls");
            }
            
            private static void ef_LimitNear(object sender, LimitEventArgs e)
            {
            e.WriteWarningWorksheet = false;
            }
            
            private static void ef_LimitReached(object sender, LimitEventArgs e)
            {
            switch(e.Operation)
            {
            case LimitEventOperation.XlsReading:
            Console.WriteLine("Data truncated while reading XLS file: " + e.FileName);
            break;
            
            case LimitEventOperation.CsvReading:
            Console.WriteLine("Data truncated while reading CSV file: " + e.FileName);
            break;
            
            case LimitEventOperation.XlsWriting:
            Console.WriteLine("Data truncated while writing XLS file: " + e.FileName);
            e.WriteWarningWorksheet = false;
            break;
            
            case LimitEventOperation.CsvWriting:
            Console.WriteLine("Data truncated while writing CSV file: " + e.FileName);
            break;
            }
            }
            </code>
            </example>
        </member>
        <member name="T:MB.WinEIDrive.Excel.LimitEventHandler">
            <summary>
            Delegate for handling the <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitNear">ExcelFile.LimitNear</see>
            and <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitReached">ExcelFile.LimitReached</see> events.
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.Excel.LimitEventOperation">
            <summary>
            Possible operations that can fire <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitNear">ExcelFile.LimitNear</see>
            and <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitReached">ExcelFile.LimitReached</see> events.
            </summary>
            <example> Following code demonstrates how to handle <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitNear">LimitNear</see>
            and <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitReached">LimitReached</see> events in <b>ExcelLite Free</b>.
            This sample disables warning worksheet in <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitNear">LimitNear</see> event
            handler and displays console messages in
            <see cref="E:MB.WinEIDrive.Excel.ExcelFile.LimitReached">LimitReached</see> event handler.
            <code lang="Visual Basic">
            Sub Main()
            Dim ef As ExcelFile = New ExcelFile
            
            AddHandler ef.LimitNear, AddressOf ef_LimitNear
            AddHandler ef.LimitReached, AddressOf ef_LimitReached
            
            Dim ws As ExcelWorksheet = ef.Worksheets.Add("Sheet1")
            
            Dim i As Integer
            For i = 0 To 172 - 1 Step i + 1
            ws.Cells(i, 0).Value = i
            Next
            
            ef.SaveXls("Test.xls")
            End Sub
            
            Private Sub ef_LimitNear(ByVal sender As Object, ByVal e As LimitEventArgs)
            e.WriteWarningWorksheet = False
            End Sub
            
            Private Sub ef_LimitReached(ByVal sender As Object, ByVal e As LimitEventArgs)
            Select Case e.Operation
            Case LimitEventOperation.XlsReading
            Console.WriteLine("Data truncated while reading XLS file: " + e.FileName)
            
            Case LimitEventOperation.CsvReading
            Console.WriteLine("Data truncated while reading CSV file: " + e.FileName)
            
            Case LimitEventOperation.XlsWriting
            Console.WriteLine("Data truncated while writing XLS file: " + e.FileName)
            e.WriteWarningWorksheet = False
            
            Case LimitEventOperation.CsvWriting
            Console.WriteLine("Data truncated while writing CSV file: " + e.FileName)
            
            End Select
            End Sub
            </code>
            <code lang="C#">
            static void Main(string[] args)
            {
            ExcelFile ef = new ExcelFile();
            
            ef.LimitNear += new LimitEventHandler(ef_LimitNear);
            ef.LimitReached += new LimitEventHandler(ef_LimitReached);
            
            ExcelWorksheet ws = ef.Worksheets.Add("Sheet1");
            
            for(int i=0; i!=172; i++)
            ws.Cells[i, 0].Value = i;
            
            ef.SaveXls("Test.xls");
            }
            
            private static void ef_LimitNear(object sender, LimitEventArgs e)
            {
            e.WriteWarningWorksheet = false;
            }
            
            private static void ef_LimitReached(object sender, LimitEventArgs e)
            {
            switch(e.Operation)
            {
            case LimitEventOperation.XlsReading:
            Console.WriteLine("Data truncated while reading XLS file: " + e.FileName);
            break;
            
            case LimitEventOperation.CsvReading:
            Console.WriteLine("Data truncated while reading CSV file: " + e.FileName);
            break;
            
            case LimitEventOperation.XlsWriting:
            Console.WriteLine("Data truncated while writing XLS file: " + e.FileName);
            e.WriteWarningWorksheet = false;
            break;
            
            case LimitEventOperation.CsvWriting:
            Console.WriteLine("Data truncated while writing CSV file: " + e.FileName);
            break;
            }
            }
            </code>
            </example>
        </member>
        <member name="T:MB.WinEIDrive.Excel.LineStyle">
            <summary>
            Line styles used for
            <see cref="P:MB.WinEIDrive.Excel.CellBorder.LineStyle">CellBorder.LineStyle</see>.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.MergedCellRange.Formula">
            <summary>
            Gets or sets merged range formula string.
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.Excel.MissArgFormulaToken">
            <summary>
            Formula token for holding missed argument( argument with no value ) in argument list of function.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.MissArgFormulaToken.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.MissArgFormulaToken"/> class.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.MissArgFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="T:MB.WinEIDrive.Excel.MultipleBorders">
            <summary>
            Flags for borders and border groups that can be set on the excel cell.
            </summary>
            <seealso cref="T:MB.WinEIDrive.Excel.IndividualBorder"/>
        </member>
        <member name="F:MB.WinEIDrive.Excel.MultipleBorders.All">
            <summary>
            All borders are used.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.MultipleBorders.Bottom">
            <summary>
            Bottom border.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.MultipleBorders.Diagonal">
            <summary>
            Diagonal borders.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.MultipleBorders.DiagonalDown">
            <summary>
            Diagonal-down border.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.MultipleBorders.DiagonalUp">
            <summary>
            Diagonal-up border.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.MultipleBorders.Horizontal">
            <summary>
            Horizontal borders.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.MultipleBorders.Left">
            <summary>
            Left border.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.MultipleBorders.None">
            <summary>
            None of the borders are used.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.MultipleBorders.Outside">
            <summary>
            Outside borders.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.MultipleBorders.Right">
            <summary>
            Right border.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.MultipleBorders.Top">
            <summary>
            Top border.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.MultipleBorders.Vertical">
            <summary>
            Vertical borders.
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.Excel.NamedRange">
            <summary>
            Represents a named range in the worksheet.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.NamedRange.#ctor(MB.WinEIDrive.Excel.NamedRangeCollection,System.Int32,System.String,MB.WinEIDrive.Excel.CellRange)">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.NamedRange"/> class.
            </summary>
            <param name="parent">Parent collection.</param>
            <param name="index">Index in the parrent collection.</param>
            <param name="name">The cell range name.</param>
            <param name="range">The named cell range.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.NamedRange.Delete">
            <summary>
            Deletes this named range from the named ranges collection.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.NamedRange.Name">
            <summary>
            Gets the named range name.
            </summary>
            <value>The named range name.</value>
        </member>
        <member name="P:MB.WinEIDrive.Excel.NamedRange.Range">
            <summary>
            Gets the named cell range.
            </summary>
            <value>The named cell range.</value>
        </member>
        <member name="T:MB.WinEIDrive.Excel.NamedRangeCollection">
            <summary>
            Collection of the descriptive names which are used
            to represent cells, ranges of cells, formulas, or constant values.
            </summary>
            <remarks>
            You can use the labels of columns and rows on a worksheet to refer to the cells within
            those columns and rows. Or you can create descriptive names to represent cells, ranges of cells,
            formulas, or constant values. Labels can be used in formulas that refer to data on the same
            worksheet; if you want to represent a range on another worksheet, use a name.
            You can also create 3-D names that represent the same cell or range of cells across multiple worksheets.
            </remarks>
            <example>Following code demonstrates how to use formulas and named ranges. It shows next features:
            cell references (both absolute and relative), unary and binary operators, constand operands (integer and floating point),
            functions and named cell ranges.
            <code lang="Visual Basic">
            ws.Cells("A1").Value = 5
            ws.Cells("A2").Value = 6
            ws.Cells("A3").Value = 10
            
            ws.Cells("C1").Formula = "=A1+A2"
            ws.Cells("C2").Formula = "=$A$1-A3"
            ws.Cells("C3").Formula = "=COUNT(A1:A3)"
            ws.Cells("C4").Formula = "=AVERAGE($A$1:$A$3)"
            ws.Cells("C5").Formula = "=SUM(A1:A3,2,3)"
            ws.Cells("C7").Formula = "= 123 - (-(-(23.5)))"
            
            ws.NamedRanges.Add("DataRange", ws.Cells.GetSubrange("A1", "A3"))
            ws.Cells("C8").Formula = "=MAX(DataRange)"
            
            Dim cr As CellRange = ws.Cells.GetSubrange("B9","C10")
            cr.Merged = True
            cr.Formula = "=A1*25"
            </code>
            <code lang="C#">
            ws.Cells["A1"].Value = 5;
            ws.Cells["A2"].Value = 6;
            ws.Cells["A3"].Value = 10;
            
            ws.Cells["C1"].Formula = "=A1+A2";
            ws.Cells["C2"].Formula = "=$A$1-A3";
            ws.Cells["C3"].Formula = "=COUNT(A1:A3)";
            ws.Cells["C4"].Formula = "=AVERAGE($A$1:$A$3)";
            ws.Cells["C5"].Formula = "=SUM(A1:A3,2,3)";
            ws.Cells["C7"].Formula = "= 123 - (-(-(23.5)))";
            
            ws.NamedRanges.Add("DataRange", ws.Cells.GetSubrange("A1", "A3"));
            ws.Cells["C8"].Formula = "=MAX(DataRange)";
            
            CellRange cr = ws.Cells.GetSubrange("B9", "C10");
            cr.Merged = true;
            cr.Formula = "=A1*25";
            </code>
            </example>
            <seealso cref="P:MB.WinEIDrive.Excel.ExcelCell.Formula">ExcelCell.Formula</seealso>
        </member>
        <member name="M:MB.WinEIDrive.Excel.NamedRangeCollection.#ctor(MB.WinEIDrive.Excel.ExcelWorksheet)">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.NamedRangeCollection"/> class.
            </summary>
            <param name="worksheet">The worksheet to initialize NamedRangesCollection.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.NamedRangeCollection.#ctor(MB.WinEIDrive.Excel.ExcelWorksheet,MB.WinEIDrive.Excel.NamedRangeCollection)">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.NamedRangeCollection">NamedRangeCollection</see> class.
            </summary>
            <param name="worksheet">The worksheet to initialize NamedRangesCollection.</param>
            <param name="sourceNamedRanges">The source named range collection to initialize NamedRangesCollection.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.NamedRangeCollection.Add(System.String,MB.WinEIDrive.Excel.CellRange)">
            <summary>
            Adds a new named range. Named ranges are used to represent cells, ranges of cells,
            formulas or constant values.
            </summary>
            <param name="name">The user-defined name.</param>
            <param name="range">The range to be refered by name.</param>
            <remarks>
            You can use the labels of columns and rows on a worksheet to refer to the cells within
            those columns and rows. Or you can create descriptive names to represent cells, ranges of cells,
            formulas, or constant values. Labels can be used in formulas that refer to data on the same
            worksheet; if you want to represent a range on another worksheet, use a name.
            You can also create 3-D names that represent the same cell or range of cells across multiple worksheets.
            </remarks>
            <example>Following code demonstrates how to use formulas and named ranges. It shows next features:
            cell references (both absolute and relative), unary and binary operators, constand operands (integer and floating point),
            functions and named cell ranges.
            <code lang="Visual Basic">
            ws.Cells("A1").Value = 5
            ws.Cells("A2").Value = 6
            ws.Cells("A3").Value = 10
            
            ws.Cells("C1").Formula = "=A1+A2"
            ws.Cells("C2").Formula = "=$A$1-A3"
            ws.Cells("C3").Formula = "=COUNT(A1:A3)"
            ws.Cells("C4").Formula = "=AVERAGE($A$1:$A$3)"
            ws.Cells("C5").Formula = "=SUM(A1:A3,2,3)"
            ws.Cells("C7").Formula = "= 123 - (-(-(23.5)))"
            
            ws.NamedRanges.Add("DataRange", ws.Cells.GetSubrange("A1", "A3"))
            ws.Cells("C8").Formula = "=MAX(DataRange)"
            
            Dim cr As CellRange = ws.Cells.GetSubrange("B9","C10")
            cr.Merged = True
            cr.Formula = "=A1*25"
            </code>
            <code lang="C#">
            ws.Cells["A1"].Value = 5;
            ws.Cells["A2"].Value = 6;
            ws.Cells["A3"].Value = 10;
            
            ws.Cells["C1"].Formula = "=A1+A2";
            ws.Cells["C2"].Formula = "=$A$1-A3";
            ws.Cells["C3"].Formula = "=COUNT(A1:A3)";
            ws.Cells["C4"].Formula = "=AVERAGE($A$1:$A$3)";
            ws.Cells["C5"].Formula = "=SUM(A1:A3,2,3)";
            ws.Cells["C7"].Formula = "= 123 - (-(-(23.5)))";
            
            ws.NamedRanges.Add("DataRange", ws.Cells.GetSubrange("A1", "A3"));
            ws.Cells["C8"].Formula = "=MAX(DataRange)";
            
            CellRange cr = ws.Cells.GetSubrange("B9", "C10");
            cr.Merged = true;
            cr.Formula = "=A1*25";
            </code>
            </example>
            <seealso cref="P:MB.WinEIDrive.Excel.ExcelCell.Formula">ExcelCell.Formula</seealso>
        </member>
        <member name="M:MB.WinEIDrive.Excel.NamedRangeCollection.DeleteInternal(System.Int32)">
            <summary>
            Deletes named range at specified index.
            </summary>
            <param name="index">The specified index.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.NamedRangeCollection.GetEnumerator">
            <summary>
            Returns an enumerator that can iterate through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/>
            that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="F:MB.WinEIDrive.Excel.NamedRangeCollection.namesList">
            <summary>
            The user-defined names list.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.NamedRangeCollection.Count">
            <summary>
            Gets the number of named ranges contained in the collection.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.NamedRangeCollection.Item(System.Int32)">
            <overloads>Gets the <see cref="T:MB.WinEIDrive.Excel.NamedRange">NamedRange</see> with
            the specified index or name.</overloads>
            <summary>
            Gets the <see cref="T:MB.WinEIDrive.Excel.NamedRange">NamedRange</see> at the specified index.
            </summary>
            <param name="index">Range index.</param>
        </member>
        <member name="P:MB.WinEIDrive.Excel.NamedRangeCollection.Item(System.String)">
            <summary>
            Gets the <see cref="T:MB.WinEIDrive.Excel.NamedRange">NamedRange</see> with the specified name.
            </summary>
            <param name="name">Range name.</param>
        </member>
        <member name="P:MB.WinEIDrive.Excel.NamedRangeCollection.NamedRanges">
            <summary>
            Gets or sets the named cell name list
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.NamedRangeCollection.Names">
            <summary>
            Gets the user-defined names. You can use these names as shortcuts for ranges, cells, etc.
            </summary>
            <value>The user-defined names.</value>
        </member>
        <member name="P:MB.WinEIDrive.Excel.NamedRangeCollection.NamesList">
            <summary>
            Gets or sets the user-defined names list.
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.Excel.NameFormulaToken">
            <summary>
            Formula token for holding the index to a NAME/EXTERNNAME record.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.NameFormulaToken.#ctor(MB.WinEIDrive.Excel.FormulaTokenCode)">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.NameFormulaToken"/> class.
            </summary>
            <param name="code">The code.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.NameFormulaToken.ConvertToBytes">
            <summary>
            Convert formula token to array of byte representation.
            </summary>
            <returns>formula token' array of byte representation</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.NameFormulaToken.DelayInitialize(System.Object[])">
            <summary>
            Make custom delay initialize.
            </summary>
            <param name="data">The data for initialization which is unique for each formula token.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.NameFormulaToken.Read(System.Byte[],System.Int32)">
            <summary>
            Initialize formula token by reading input data from array of bytes
            </summary>
            <param name="rpnBytes">input data, array of bytes</param>
            <param name="startIndex">start position for array of bytes to read from</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.NameFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="F:MB.WinEIDrive.Excel.NameFormulaToken.nameIndex">
            <summary>
            One-based index to ExternName record.
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.Excel.NameRecord">
            <summary>
            Name record for holding information about name which can be used in named cell\range
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.NameRecord.#ctor(MB.WinEIDrive.Excel.ExcelWorksheet)">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.NameRecord"/> class.
            </summary>
            <param name="worksheet">The worksheet.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.NameRecord.#ctor(System.Int32,System.IO.BinaryReader,MB.WinEIDrive.Excel.AbsXLSRec)">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.NameRecord"/> class.
            </summary>
            <param name="bodyLength">Length of the body.</param>
            <param name="br">The binary readed to read from.</param>
            <param name="previousRecord">The previous record.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.NameRecord.ConvertNameRecordRangeToRpnBytes(MB.WinEIDrive.Excel.CellRange,System.String,MB.WinEIDrive.Excel.ExcelWorksheetCollection)">
            <summary>
            Converts the name record range to RPN bytes.
            </summary>
            <param name="range">The range to be converted.</param>
            <param name="sheetName">Sheet' name.</param>
            <param name="worksheets">The worksheets collection.</param>
        </member>
        <member name="P:MB.WinEIDrive.Excel.NameRecord.NameValue">
            <summary>
            Gets or sets the name value.
            </summary>
            <value>The name value.</value>
        </member>
        <member name="P:MB.WinEIDrive.Excel.NameRecord.Range">
            <summary>
            Gets or sets the range to be associated with the user-defined name.
            </summary>
            <value>The range to be associated with the user-defined name.</value>
        </member>
        <member name="P:MB.WinEIDrive.Excel.NameRecord.RpnBytes">
            <summary>
            Gets or sets the RPN bytes of formula used for referencing 3d cell or area.
            </summary>
            <value>The RPN bytes of formula used for referencing 3d cell or area.</value>
        </member>
        <member name="P:MB.WinEIDrive.Excel.NameRecord.SheetIndex">
            <summary>
            Gets or sets the index for the sheet which contain named cell\range.
            </summary>
            <value>The index for the sheet which contain named cell\range.</value>
        </member>
        <member name="P:MB.WinEIDrive.Excel.NameRecord.Worksheets">
            <summary>
            Gets or sets the workbook\worksheets collection.
            </summary>
            <value>The workbook\worksheets collection.</value>
        </member>
        <member name="M:MB.WinEIDrive.Excel.NumberFormatCollection.SetNumberFormat(System.Int32,System.String)">
            <summary>
            This method is designed to be used ONLY for Excel file reading.
            </summary>
            <param name="index"></param>
            <param name="formatString"></param>
        </member>
        <member name="T:MB.WinEIDrive.Excel.NumbersParser">
            <summary>
            Class used for controling number format
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.NumbersParser.#cctor">
            <summary>
            Initialize object
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.NumbersParser.IsUshort(System.Double)">
            <summary>
            Determines whether the specified double value is ushort( integer ).
            </summary>
            <param name="doubleValue">The double value.</param>
            <returns>
            <c>true</c> if the specified double value is ushort; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.NumbersParser.StrToDouble(System.String)">
            <summary>
            Convert string to double.
            </summary>
            <param name="data">string data.</param>
            <returns>double data.</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.NumbersParser.StrToFloat(System.String)">
            <summary>
            Converts string to float.
            </summary>
            <param name="str">strind data.</param>
            <returns>flot data.</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.NumbersParser.StrToInt(System.String)">
            <summary>
            Converts string to int.
            </summary>
            <param name="data">string data.</param>
            <returns>int data.</returns>
        </member>
        <member name="F:MB.WinEIDrive.Excel.NumbersParser.formatProvider">
            <summary>
            Number format for string conversion
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.NumbersParser.Provider">
            <summary>
            Get number format info instance
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.Excel.NumFormulaToken">
            <summary>
            Formula token for holding integer.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.NumFormulaToken.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.NumFormulaToken"/> class.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.NumFormulaToken.ConvertToBytes">
            <summary>
            Convert formula token to array of byte representation.
            </summary>
            <returns>formula token' array of byte representation</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.NumFormulaToken.DelayInitialize(System.Object[])">
            <summary>
            Make custom delay initialize.
            </summary>
            <param name="data">The data for initialization which is unique for each formula token.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.NumFormulaToken.Read(System.Byte[],System.Int32)">
            <summary>
            Initialize formula token by reading input data from array of bytes
            </summary>
            <param name="rpnBytes">input data, array of bytes</param>
            <param name="startIndex">start position for array of bytes to read from</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.NumFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="T:MB.WinEIDrive.Excel.RangeIndexingMode">
            <summary>
            Indexing modes used by <see cref="T:MB.WinEIDrive.Excel.CellRange">CellRange</see>.
            </summary>
            <example> Following code creates horizontal, vertical and rectangular cell ranges and demonstrates how
            indexing works different in different context. <see cref="M:MB.WinEIDrive.Excel.CellRange.SetBorders(MB.WinEIDrive.Excel.MultipleBorders,System.Drawing.Color,MB.WinEIDrive.Excel.LineStyle)">SetBorders</see>
            method is used to mark outside borders of the rectangular range.
            <code lang="Visual Basic">
            Dim cr As CellRange = excelFile.Worksheets(0).Rows(1).Cells
            
            cr(0).Value = cr.IndexingMode
            cr(3).Value = "D2"
            cr("B").Value = "B2"
            
            cr = excelFile.Worksheets(0).Columns(4).Cells
            
            cr(0).Value = cr.IndexingMode
            cr(2).Value = "E3"
            cr("5").Value = "E5"
            
            cr = excelFile.Worksheets(0).Cells.GetSubrange("F2", "J8")
            cr.SetBorders(MultipleBorders.Outside, Color.Navy, LineStyle.Dashed)
            
            cr("I7").Value = cr.IndexingMode
            cr(0, 0).Value = "F2"
            cr("G3").Value = "G3"
            cr(5).Value = "F3" <font color="Green">' Cell range width is 5 (F G H I J).</font>
            </code>
            <code lang="C#">
            CellRange cr = excelFile.Worksheets[0].Rows[1].Cells;
            
            cr[0].Value = cr.IndexingMode;
            cr[3].Value = "D2";
            cr["B"].Value = "B2";
            
            cr = excelFile.Worksheets[0].Columns[4].Cells;
            
            cr[0].Value = cr.IndexingMode;
            cr[2].Value = "E3";
            cr["5"].Value = "E5";
            
            cr = excelFile.Worksheets[0].Cells.GetSubrange("F2", "J8");
            cr.SetBorders(MultipleBorders.Outside, Color.Navy, LineStyle.Dashed);
            
            cr["I7"].Value = cr.IndexingMode;
            cr[0,0].Value = "F2";
            cr["G3"].Value = "G3";
            cr[5].Value = "F3"; <font color="Green">// Cell range width is 5 (F G H I J).</font>
            </code>
            </example>
            <seealso cref="P:MB.WinEIDrive.Excel.CellRange.IndexingMode"/>
        </member>
        <member name="T:MB.WinEIDrive.Excel.Ref3dFormulaToken">
            <summary>
            Formula token for holding 3d reference on internal cell.
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.Excel.RefFormulaToken">
            <summary>
            Formula token for holding reference.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.RefFormulaToken.ColumnBitMask">
            <summary>
            Bit mask for column options.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.RefFormulaToken.RowBitMask">
            <summary>
            Bit mask for row options.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.RefFormulaToken.#ctor(MB.WinEIDrive.Excel.FormulaTokenCode)">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.RefFormulaToken"/> class.
            </summary>
            <param name="code">The code.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.RefFormulaToken.ConvertToBytes">
            <summary>
            Convert formula token to array of byte representation.
            </summary>
            <returns>formula token' array of byte representation</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.RefFormulaToken.DelayInitialize(System.Object[])">
            <summary>
            Make custom delay initialize.
            </summary>
            <param name="data">The data for initialization which is unique for each formula token.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.RefFormulaToken.Read(System.Byte[],System.Int32)">
            <summary>
            Initialize formula token by reading input data from array of bytes
            </summary>
            <param name="rpnBytes">input data, array of bytes</param>
            <param name="startIndex">start position for array of bytes to read from</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.RefFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="F:MB.WinEIDrive.Excel.RefFormulaToken.AbsoluteCellMark">
            <summary>
            Absolute preffix row\height symbol
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.RefFormulaToken.IsCellRegex">
            <summary>
            Regular expression used to determinate whether the input string is cell or not
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.RefFormulaToken.IsColumnRegex">
            <summary>
            Regular expression used to determinate whether the input string is column or not
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.RefFormulaToken.regexOptions">
            <summary>
            Regular expression default options
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.Ref3dFormulaToken.#ctor(MB.WinEIDrive.Excel.FormulaTokenCode)">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.Ref3dFormulaToken"/> class.
            </summary>
            <param name="code">The code.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.Ref3dFormulaToken.ConvertToBytes">
            <summary>
            Convert formula token to array of byte representation.
            </summary>
            <returns>formula token' array of byte representation</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.Ref3dFormulaToken.DelayInitialize(System.Object[])">
            <summary>
            Make custom delay initialize.
            </summary>
            <param name="data">The data for initialization which is unique for each formula token.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.Ref3dFormulaToken.Read(System.Byte[],System.Int32)">
            <summary>
            Initialize formula token by reading input data from array of bytes
            </summary>
            <param name="rpnBytes">input data, array of bytes</param>
            <param name="startIndex">start position for array of bytes to read from</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.Ref3dFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="F:MB.WinEIDrive.Excel.Ref3dFormulaToken.IsCell3DRegex">
            <summary>
            Regular expression used to determinate whether the input string is 3d cell or not
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.Ref3dFormulaToken.refIndex">
            <summary>
            REF entry' index on EXTERNSHEET record( see the Link Table ).
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.Ref3dFormulaToken.regexOptions">
            <summary>
            Regular expression default options
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.Excel.RefErr3dFormulaToken">
            <summary>
            Formula token for holding 3d reference error on internal cell range.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.RefErr3dFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="T:MB.WinEIDrive.Excel.RefErrFormulaToken">
            <summary>
            Formula token for holding reference error.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.RefErrFormulaToken.#ctor(MB.WinEIDrive.Excel.FormulaTokenCode)">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.RefErrFormulaToken"/> class.
            </summary>
            <param name="code">The code.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.RefErrFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="T:MB.WinEIDrive.Excel.RowColumnResolutionMethod">
            <summary>
            Defines different methods of <see cref="T:MB.WinEIDrive.Excel.CellStyle">CellStyle</see> resolution.
            </summary>
            <seealso cref="P:MB.WinEIDrive.Excel.ExcelFile.RowColumnResolutionMethod">ExcelFile.RowColumnResolutionMethod</seealso>
        </member>
        <member name="T:MB.WinEIDrive.Excel.ScriptPosition">
            <summary>
            Script positions used in <see cref="P:MB.WinEIDrive.Excel.ExcelFont.ScriptPosition">ExcelFont.ScriptPosition</see>.
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.Excel.SheetIndexes">
            <summary>
            SheetIndexes structure for storing index to SupBook record
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.SheetIndexes.#ctor(System.IO.BinaryReader)">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.SheetIndexes"/> class.
            </summary>
            <param name="br">The binary reader to read from.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.SheetIndexes.#ctor(System.UInt16)">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.SheetIndexes"/> class.
            </summary>
            <param name="sheetIndex">The first/last sheet index.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.SheetIndexes.Write(System.IO.BinaryWriter)">
            <summary>
            Writes the REF' data to the specified binary writer.
            </summary>
            <param name="bw">The destination binary writer.</param>
        </member>
        <member name="F:MB.WinEIDrive.Excel.SheetIndexes.sheetIndex">
            <summary>
            Index to first/last sheet
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.SheetIndexes.SheetIndex">
            <summary>
            Gets or sets the first/last sheet index.
            </summary>
            <value>The first/last sheet index.</value>
        </member>
        <member name="P:MB.WinEIDrive.Excel.SheetIndexes.Size">
            <summary>
            Gets the size of REF' storage.
            </summary>
            <value>The size of REF' storage.</value>
        </member>
        <member name="T:MB.WinEIDrive.Excel.StrFormulaToken">
            <summary>
            Formula token for holding string.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.StrFormulaToken.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.StrFormulaToken"/> class.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.StrFormulaToken.ConvertToBytes">
            <summary>
            Convert formula token to array of byte representation.
            </summary>
            <returns>formula token' array of byte representation</returns>
        </member>
        <member name="M:MB.WinEIDrive.Excel.StrFormulaToken.DelayInitialize(System.Object[])">
            <summary>
            Make custom delay initialize.
            </summary>
            <param name="data">The data for initialization which is unique for each formula token.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.StrFormulaToken.Read(System.Byte[],System.Int32)">
            <summary>
            Initialize formula token by reading input data from array of bytes
            </summary>
            <param name="rpnBytes">input data, array of bytes</param>
            <param name="startIndex">start position for array of bytes to read from</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.StrFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="T:MB.WinEIDrive.Excel.SupBookRecord">
            <summary>
            SupBookRecord record is used to provide information about internal 3d references
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.SupBookRecord.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.SupBookRecord"/> class.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.SupBookRecord.#ctor(System.Int32,System.IO.BinaryReader,MB.WinEIDrive.Excel.AbsXLSRec)">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.SupBookRecord"/> class.
            </summary>
            <param name="bodyLength">Length of the body.</param>
            <param name="br">The binary reader to read from.</param>
            <param name="previousRecord">The previous record.</param>
        </member>
        <member name="P:MB.WinEIDrive.Excel.SupBookRecord.SheetsCount">
            <summary>
            Gets or sets the sheets count in current workbook.
            </summary>
            <value>The sheets count in current workbook.</value>
        </member>
        <member name="T:MB.WinEIDrive.Excel.UnaryOperatorFormulaToken">
            <summary>
            Formula token for holding unary operator.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.UnaryOperatorFormulaToken.#cctor">
            <summary>
            Initializes the <see cref="T:MB.WinEIDrive.Excel.UnaryOperatorFormulaToken"/> class.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.UnaryOperatorFormulaToken.#ctor(MB.WinEIDrive.Excel.FormulaTokenCode)">
            <summary>
            Initializes a new instance of the <see cref="T:MB.WinEIDrive.Excel.UnaryOperatorFormulaToken"/> class.
            </summary>
            <param name="code">The code.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.UnaryOperatorFormulaToken.ToString">
            <summary>
            Convert formula token to string representation.
            </summary>
            <returns>formula token string representation</returns>
        </member>
        <member name="T:MB.WinEIDrive.Excel.UnderlineStyle">
            <summary>
            Underline styles used in <see cref="P:MB.WinEIDrive.Excel.ExcelFont.UnderlineStyle">ExcelFont.UnderlineStyle</see>.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.UnderlineStyle.Double">
            <summary>
            Double underline. Underlines only cell data.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.UnderlineStyle.DoubleAccounting">
            <summary>
            Double accounting underline. Underlines whole cell.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.UnderlineStyle.None">
            <summary>
            No underline.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.UnderlineStyle.Single">
            <summary>
            Single underline. Underlines only cell data.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.UnderlineStyle.SingleAccounting">
            <summary>
            Single accounting underline. Underlines whole cell.
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.Excel.VerticalAlignmentStyle">
            <summary>
            Vertical alignment styles used for <see cref="P:MB.WinEIDrive.Excel.CellStyle.VerticalAlignment">
            CellStyle.VerticalAlignment</see>.
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.Excel.VerticalPageBreak">
            <summary>
            Specifies a vertical position where the new page begins when the worksheet is printed.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.VerticalPageBreak.Column">
            <summary>
            Index of the first column of the new page.
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Excel.VerticalPageBreak.FirstRow">
            <summary>
            Index of the first row of the new page.
            </summary>
            <remarks>
            Use 0 (first row) if you don't care.
            </remarks>
        </member>
        <member name="P:MB.WinEIDrive.Excel.VerticalPageBreak.LastRow">
            <summary>
            Index of the last row of the new page.
            </summary>
            <remarks>
            Use 65535 (last row) if you don't care.
            </remarks>
        </member>
        <member name="T:MB.WinEIDrive.Excel.VerticalPageBreakCollection">
            <summary>
            Collection of vertical page breaks (<see cref="T:MB.WinEIDrive.Excel.VerticalPageBreak">VerticalPageBreak</see>).
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.VerticalPageBreakCollection.Add(System.Int32)">
            <overloads>Ads a new vertical page break.</overloads>
            <summary>
            Ads a new vertical page break left to the specified column.
            </summary>
            <param name="column">The zero-based index of the column.</param>
        </member>
        <member name="M:MB.WinEIDrive.Excel.VerticalPageBreakCollection.Add(System.Int32,System.Int32,System.Int32)">
            <summary>
            Ads a new vertical page break left to the specified column and within specified rows.
            </summary>
            <param name="column">The zero-based index of the column.</param>
            <param name="firstRow">The zero-based index of the first row.</param>
            <param name="lastRow">The zero-based index of the last row.</param>
        </member>
        <member name="P:MB.WinEIDrive.Excel.VerticalPageBreakCollection.Item(System.Int32)">
            <summary>
            Gets or sets the vertical page break at the specified index.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.WorksheetWindowOptions.ColumnsFromRightToLeft">
            <summary>
            If set, MS Excel shows columns from right to left.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.WorksheetWindowOptions.DefaultGridLineColor">
            <summary>
            If set, MS Excel uses default grid line color.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.WorksheetWindowOptions.FrozenNoSplit">
            <summary>
            If set, MS Excel removes splits if pane freeze is removed.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.WorksheetWindowOptions.FrozenPanes">
            <summary>
            If set, panes are frozen in MS Excel.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.WorksheetWindowOptions.SheetSelected">
            <summary>
            Set if sheet is selected in MS Excel.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.WorksheetWindowOptions.SheetVisible">
            <summary>
            Set if sheet is visible in MS Excel.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.WorksheetWindowOptions.ShowFormulas">
            <summary>
            If set, MS Excel shows formulas. Otherwise, formula results are shown.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.WorksheetWindowOptions.ShowGridLines">
            <summary>
            If set, MS Excel shows grid lines.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.WorksheetWindowOptions.ShowInPageBreakPreview">
            <summary>
            If set, MS Excel shows worksheet in page break preview. Otherwise, normal view is used.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.WorksheetWindowOptions.ShowOutlineSymbols">
            <summary>
            If set, MS Excel shows outline symbols.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.WorksheetWindowOptions.ShowSheetHeaders">
            <summary>
            If set, MS Excel shows row and column headers.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.WorksheetWindowOptions.ShowZeroValues">
            <summary>
            If set, MS Excel shows zero values. Otherwise, zero values are shown as empty cells.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Excel.XLSFileWriter.WriteGlobalRecords(MB.WinEIDrive.Excel.AbsXLSRecords,System.Collections.ArrayList,System.Collections.ArrayList)">
            <summary>
            Writes the global records.
            </summary>
            <param name="records">The records.</param>
            <param name="worksheetRecords">The worksheet records.</param>
            <param name="worksheetNames">The worksheet names.</param>
        </member>
        <member name="T:MB.WinEIDrive.Excel.XlsOptions">
            <summary>
            Options specified when reading XLS files.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.XlsOptions.None">
            <summary>
            Do not preserve records. Only records fully supported by ExcelLite API will be loaded.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.XlsOptions.PreserveAll">
            <summary>
            Preserve all possible information.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.XlsOptions.PreserveGlobalRecords">
            <summary>
            Preserve global (workbook) records.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.XlsOptions.PreserveSummaries">
            <summary>
            Preserve summaries.
            </summary>
        </member>
        <member name="F:MB.WinEIDrive.Excel.XlsOptions.PreserveWorksheetRecords">
            <summary>
            Preserve worksheet records.
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.Export.ExportBase">
            <summary>
            ImportBase 数据导入的基本处理。
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.Export.ExportXls">
            <summary>
            ExportXls 导出Excel 操作。
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.Export.IExportProvider">
            <summary>
            IExportProvider 数据导出的接口说明。
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Export.ExportXls.#ctor(System.String,System.Boolean)">
            <summary>
            提供把相应的数据源导出到Excel 文件中。
            </summary>
            <param name="fileName"></param>
            <param name="openExportFile"></param>
        </member>
        <member name="M:MB.WinEIDrive.Export.ExportXls.#ctor(System.Object,System.String,System.Boolean)">
            <summary>
            把DataSet 导出到指定的Excel 文件中。
            </summary>
            <param name="dsData"></param>
            <param name="fullFileName"></param>
            <param name="openExportFile"></param>
        </member>
        <member name="M:MB.WinEIDrive.Export.ExportXls.Commit">
            <summary>
            提交数据导出的操作。
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.FileLib">
            <summary>
            FileLib 文件操作类。
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.FileLib.#ctor">
            <summary>
            add private construct function to prevent instance.
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.FileLib.TryToOpenFile(System.String)">
            <summary>
             打开文件。
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="T:MB.WinEIDrive.Import.IImportProvider">
            <summary>
            IImportProvider 数据导入接口说明。
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Import.OfficeXlsImport.#ctor(System.Object,System.String)">
            <summary>
            构造函数...
            </summary>
            <param name="dtData"></param>
            <param name="fullFileName"></param>
        </member>
        <member name="M:MB.WinEIDrive.Import.OfficeXlsImport.Commit">
            <summary>
            执行数据导入的操作。
            </summary>
            <returns></returns>
        </member>
        <member name="M:MB.WinEIDrive.Import.OfficeXlsImport.LoadExcelToDataTable(System.String)">
            <summary>  
            加载Excel表到DataTable，跟原始Excel表形式一样，需要筛选自己有用的数据  
            </summary>  
            <param name="filename">需要读取的Excel文件路径</param>  
            <param name="sheetname">工作表名称</param>  
            <returns>DataTable</returns>  
        </member>
        <member name="P:MB.WinEIDrive.Import.OfficeXlsImport.ImportData">
            <summary>
            获取正在导入的数据。
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.Import.TxtImport">
            <summary>
            TxtImport : 从文件文件中导入数据
            </summary>
        </member>
        <member name="P:MB.WinEIDrive.Import.TxtImport.ImportData">
            <summary>
            获取正在导入的数据。
            </summary>
        </member>
        <member name="T:MB.WinEIDrive.Import.XlsImport">
            <summary>
            XlsImport 从Excel 中导入数据。
            </summary>
        </member>
        <member name="M:MB.WinEIDrive.Import.XlsImport.#ctor(System.Object,System.String)">
            <summary>
            构造函数...
            </summary>
            <param name="dtData"></param>
            <param name="fullFileName"></param>
        </member>
        <member name="M:MB.WinEIDrive.Import.XlsImport.Commit">
            <summary>
            执行数据导入的操作。
            </summary>
            <returns></returns>
        </member>
        <member name="P:MB.WinEIDrive.Import.XlsImport.ImportData">
            <summary>
            获取正在导入的数据。
            </summary>
        </member>
    </members>
</doc>
